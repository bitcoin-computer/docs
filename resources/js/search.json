[[{"i":"#","p":["This is a custom description for this page"]},{"l":"Bitcoin Computer","p":["The Bitcoin Computer is a powerful on-chain L2 smart contract system that is designed specifically for UTXO-based blockchains.","Some of the key features include:","Low fees through client-side validation","The ability to write smart contracts in popular programming languages such as Javascript and Typescript","Seamless integration into web applications","Built-in privacy features such as off-chain storage and encryption","Support for non-custodial applications","Trustless and censorship-resistant design","Compliance with ES6 module system","Compatibility with both browser and node.js environments","Support for Litecoin, with support for Bitcoin and Dogecoin coming soon","With the Bitcoin Computer, you can build a wide range of decentralized applications, such as fungible and non-fungible tokens, exchanges, games, office applications, social networks, messengers, AI-based applications, and much more."]},{"l":"Getting Started","p":["The best way to get started is to clone this repository and run one of the examples."]},{"l":"Examples","p":["The examples are in the packages folder. To run an example have a look at the README.md file in the corresponding folder."]},{"l":"Applications","p":["Wallet: A minimal non-custodial wallet","Chat: A p2p chat application where messages are communicated over the blockchain","Fungible Token: An application for minting, sending, and storing fungible tokens","Non Fungible Token: An application for minting, sending, and storing non-fungible tokens (NFTs)"]},{"l":"Standard Smart Contracts","p":["BRC20 contract: A implementation of the ERC20 Fungible Token Standard","BRC721 contract: A implementation of the ERC721 Non-Fungible Token Standard"]},{"l":"Templates","p":["Bitcoin Computer Node.js Template: A template for starting a new Bitcoin Computer application with node.js","Bitcoin Computer React Template: A template for starting a new Bitcoin Computer application with Create React App"]},{"l":"Core Library","p":["The core smart contract library is based on two packages:","Bitcoin Computer Lib A non-custodial web wallet for reading and writing smart contracts","Bitcoin Computer Node Server side infrastructure for providing trustless access to smart contracts"]},{"l":"Price","p":["It is free to develop and test a Bitcoin Computer application on testnet and regtest.","On Mainnet the fees for using the Bitcoin Computer are on average the same as the transaction fees charged by miners fees. For example, if the miner transaction fee is one cent, then you pay two cent in total: one cent to the miners, and one cent to support the development of the Bitcoin Computer."]},{"l":"Development Status","p":["We have completed two internal audits and addressed any discovered issues. Currently, there are no known security vulnerabilities, however, it is possible that unknown vulnerabilities may exist. We plan to conduct one more thorough internal security audit prior to recommending the usage of the Bitcoin Computer in production environments."]},{"l":"Getting Help","p":["If you have any questions, please let us know in our Telegram group, on Twitter, or by email clemens@bitcoincomputer.io."]},{"l":"License","p":["Bitcoin Computer Lib and Bitcoin Computer Node are licensed under the Creative Commons Attribution-NoDerivs 3.0 Unported License. All other packages in this monorepo are licensed under the MIT License. See the individual packages for more information."]}],[{"l":"Start","p":["If you are trying out the Bitcoin Computer for the first time we recommend to follow the readme file of the Bitcoin Computer Library. If you want to integrate into a new or existing application you will also need the Bitcoin Computer Library.","Bitcoin Computer Library","You can run a Bitcoin Computer Node through docker. You need to run a node if you want to run an application on mainnet. It also offers a great development experience.","Bitcoin Computer Node","You can run one of the example applications by cloning the monorepo.","Bitcoin Computer Monorepo"]}],[{"l":"Tutorial"},{"l":"Write a Smart Contract","p":["Every Javascript (ES6) class that extends from Contract is a smart contract. For example, a smart contract for a chat could be:"]},{"l":"Create a Wallet","p":["Next, create a smart contract wallet from the Bitcoin Computer library.","You can pass in a BIP39 mnemonic to initialize the wallet. You can generate a mnemonic here. See here for more configuration options."]},{"l":"Create a Smart Object","p":["The computer.new function can be used to create an object from a smart contract and to store it on the blockchain. For example","When computer.new is called with these parameters a transaction containing the expression `${Chat} new Chat('hi')` is broadcast to record that the constructor was called. The object a that is returned to the user has all the properties defined in the class, and five extra properties _id, _rev, _root, _owners and _amount.","The properties _id, _root and _rev are set to the same value: 667c...2357/0. We will explain these properties in detail later, for now it is sufficient to know that 667c...2357 is the transaction id of the transaction that contains the expression `${Chat} new Chat('hi')`. The property _owners is an array of public keys that are allowed to update the object. The property _amount is the amount of satoshis that are required to update the object."]},{"l":"Read a Smart Object","p":["The computer.sync function can be used to parse the expressions of the blockchain back into Javascript objects. For example, if we call computer.sync with the string 667c...2357/0 it will recover the original object:","We note that reading and writing can be performed to different users. The blockchain allows them to obtain consensus over the state of smart objects. This makes it possible to build decentralized applications."]},{"l":"Update a Smart Object","p":["A smart object can be updated through function calls. However, as function calls are recorded in Bitcoin transactions, it is necessary to await on function calls:","We can see that the messages array was updated as expected.","We can also see that _rev has been update but that _id and _root stayed the same. Every time a smart object is updated a new revision is created and assigned to the _rev property. We will explain the _id and the _root property in detail later, for now we note that they remain fixed throughout the lifecycle of an object.","Revisions allow you to query each historical state of an object:"]},{"l":"Find Smart Objects","p":["The computer.query function provides a simple way of finding the latest revisions of smart objects.","A basic pattern is to identify smart objects by their id, look up their latest revision using computer.query and then to compute their latest state using computer.sync. For example, in a chat, we might have the url for the chat containing the id of the chat object. We could then recover the latest state of the chat as follows:"]},{"l":"Data Ownership","p":["Every smart object has one or more owners and only the owners can update the object. The owners can be set by assigning string encoded public keys to the _owners property. If the _owners property is not assigned in a smart contract it defaults to the public key of the computer object that created the smart object.","For example, in our chat example the only owner will be the user that created the chat with computer.new. Thus only that user will be able to post to the chat which is a little boring. So we can add a function to update the owners array to invite more guests to chat."]},{"l":"Privacy","p":["By default, the state of all smart objects is publicly visible. However, you can restrict read access to the object by setting a property _readers. If _readers is assigned to an array of public keys, the meta-data of the current revision is encrypted in a way that only the specified readers can decrypt it.","For example, if we want to ensure that only people invited to the chat can read the messages, we can update our example code as follows:","A user can (only) read the state of a smart object if they have read access to the current and all previous versions of the object. It is, therefore, not possible to revoke access that has already been granted from smart objects. However, it is possible to remove a user's ability to read the state of a smart object from a point in time forwards.","Both encryption and decryption happen securely in users' browsers. We note that while all smart contract data is encrypted, flows of money are not obfuscated in order not to hinder anti-money laundering efforts."]},{"l":"Saving Block Space","p":["It is sometimes not the best choice to store data on the blockchain. For example, if there's a large amount of data, it might be too expensive. Other data, like personal data, should never be stored on chain, not even encrypted, in order to comply with privacy regulations, such as CCPA and GDPR.","The property _url of each smart object can be used to specify the URL of a Bitcoin Computer Node. When this property is set, the meta data that encodes an update is not recorded on the blockchain, but instead is stored on the specified Bitcoin Computer Node. The blockchain only contains a hash of the meta data and a link to where it can be retrieved.","For example, if we want to allow users to send images that are too large to be stored on chain to the chat, we can make use of the off-chain solution:"]},{"l":"Cryptocurrency","p":["Each smart object can store an amount of cryptocurrency. By default a smart object stores a minimal (non-dust) amount. The smart contract developer can set an amount by assigning an integer to a property _amount of a smart object.","For example, consider the class Payment below.","If a user A wants to send 210000 satoshis to a user B, the user A can setup the payment as follows:","When the payment smart object is created, the wallet inside the computerA object funds the 210000 satoshi that are stored in the payment object.","Generally, constructor and function calls with no parameters work in the same way: The computer object that either created or synced against the smart object has to cover the satoshis in a smart object without parameters.","In the case of a constructor or function call with parameters we first check if the parameters contain enough funds to cover the amount in the parameters after the call and the amount(s) in the return value. If so, no additional fees from the \"current\" wallet is needed. If the amount in the parameters exceeds the amount specified in the smart object the funds are sent back to the \"current\" wallet.","For B to claim the funds, in the next step A can send send payment._rev to user B. Then, the user B can execute:","At the end of the process 210000-10000=200000 many additional satoshis will be in the wallet with seed B's seed phrase."]}],[{"l":"API","p":["This section outlines the API for the Computer class, which allows for the creation and storage of smart objects on the blockchain. It also enables querying for the location of these objects and calculating their latest values. The Computer class serves as the primary interface for the Bitcoin Computer API."]},{"l":"Basic"},{"l":"Constructor","p":["The \"Computer\" class constructor creates objects capable of creating smart contract transactions as well as standard payments. Each such object is connected to a Bitcoin or Litecoin node and can broadcast transactions and access blockchain information. The constructor parameters are optional and can be used to specify the target blockchain, network, and wallet."]},{"i":"new","l":"new()","p":["This method creates new smart objects. The parameters are a class, a list of arguments for the constructor of the class, and a module specifier. The arguments can be of basic data type or smart objects.","Here a Location is the type"]},{"i":"query","l":"query()","p":["Returns an array of strings, containing the latest revisions of smart objects that satisfy certain conditions. For example, one can obtain all revisions owned by a public key or all revisions of a specific smart contract.","When a key is omitted, the condition is ignored. For example, if only class is set in the contract parameter, the call will return all revisions of that class regardless of the owners."]},{"i":"sync","l":"sync()","p":["This returns the smart object stored at a given revision."]},{"l":"Advanced","p":["Most smart contracts can be implemented using the basic methods. However, the following methods can be used to implement more complex contracts that use for example off-chain signing or server-side funding."]},{"i":"encode","l":"encode()","p":["Encodes an expression, an environment and a module specifier into a Bitcoin transaction of type Transaction as in the Bitcore Library."]},{"i":"decode","l":"decode()","p":["Converts a Bitcore transaction into a transition object. The inverse of encode."]},{"i":"encodenew","l":"encodeNew()","p":["Encodes a smart object creation into a Bitcoin transaction."]},{"i":"encodecall","l":"encodeCall()","p":["Encodes a smart object call into a Bitcoin transaction that can be broadcasted to the Bitcoin mining network."]},{"l":"Modules"},{"l":"export","p":["To optimize blockchain storage and reduce transaction costs, consider exporting your modules. This separates the modules from your smart objects, enabling the code for a class to be stored just once. Later in the text, we'll explain the process of funding, signing, and broadcasting the transaction."]},{"l":"import","p":["Imports a smart contract from a module specifier. Future versions of the library will support importing modules from within an expression. For now, you can import modules from the blockchain using the revision as described in the previous section."]},{"l":"Wallet"},{"l":"fund","p":["Funds a Bitcoin transaction with UTXOs from the wallet."]},{"l":"sign","p":["Signs a Bitcore transaction with the private key of the wallet. The transaction needs to be fully funded before it can be signed. If multiple parties are involved in the transaction, each party needs to sign the transaction before it can be broadcasted."]},{"l":"broadcast","p":["Broadcasts a Bitcoin transaction to the Bitcoin mining network."]},{"l":"send","p":["Sends an amount of satoshis to an address."]},{"l":"rpcCall","p":["Calls a Bitcoin RPC method with the given parameters."]},{"l":"getAddress","p":["Returns a string encoding Bitcoin address."]},{"l":"getBalance","p":["Returns the current balance in satoshi."]},{"l":"getPublicKey","p":["Returns a string encoding a public key."]},{"l":"getChain","p":["Returns the chain of the computer object."]},{"l":"getNetwork","p":["Returns the network of the computer object."]},{"l":"getMenmonic","p":["Returns a string encoding a BIP32 mnemonic sentence of the computer object."]},{"l":"getPassphrase","p":["Returns the passphrase of the computer object."]},{"l":"getPrivateKey","p":["Returns a string encoding a private key."]},{"i":"getpublickey-1","l":"getPublicKey","p":["Returns a string encoding a public key."]},{"l":"getUtxos","p":["Returns an array of UTXOs."]}],[{"l":"Wallet","p":["A wallet allows a user to check their balance and make a transaction to send cryptocurrency to another user.","In order to build the transaction, we can use a Bitcore-style library. Bitcoin Computer Lib can provide data to the wallet and broadcast the transaction. A BIP39 mnemonic sentence can be employed to generate a Bitcoin Computer wallet.","You can use the computer object to calculate the balance of a given address.","The easy way to send money to a friend is to use the send function:","Check out a working version on Github"]}],[{"l":"Chat","p":["The Bitcoin Chat presented here is a hackable chat that runs on the blockchain. The chat does not need a database backend because all data is stored on the blockchain (currently runs on LTC testnet). The interface between the chat and the blockchain is provided by Bitcoin Computer.","The Chat class has a constructor and two functions, post and invite.","The constructor initializes a owner of the chat and an empty messages array. The post function stores the new messages, and the invite function records the users who join the chat.","Check out a working version on Github."]}],[{"l":"Non-Fungible Token","p":["Let's explore how ERC721 style non-fungible token (NFT) contracts can be implemented on Bitcoin.","In the NFT class, we have a constructor and a send function. The constructor initializes a new token with a url and an initial owner. The send function adds the new owner to the list of owners of this token."]},{"l":"BRC721","p":["BRC721 is the ERC721 standard built on Bitcoin. It currently implements the IBRC721 interface.","The BRC721 class has the following functions: mint, balanceOf, ownerOf, and transfer. The mint function mints a new non-fungible token. It first checks whether or not there is a masterNFT. If not, and a name and a symbol are inputted, the computer generates a new NFT, which includes the name and symbol and a new owner's information, and sets it as this BRC721's masterNFT. If there's already a masterNFT, but its name does not match the name inputted, or the symbol does not match, throw an error. Otherwise, the masterNFT will mint a new token with the new owner's information.","The balanceOf function returns the number of NFTs the user owns. The ownerOf function returns the owner of a given token ID. The transfer function allows you to send the token to another user.","Check out a working version of the BRC721 contract and a NFT application."]}],[{"l":"Fungible Token","p":["We explore how ERC20 style fungible token contracts can be built on Bitcoin. The BRC20 class implements the interface described in EIP20.","We use two classes: a TokenBag encapsulates the minimal amount of data that needs to be stored on the blockchain. A token bag can be thought of as the equivalent to unspent transaction output (utxo) in the token world: while a utxo stores a number of satoshi, a token bag stores a number of tokens. The ERC20 class helps manage multiple token bags, in the same way that a wallet deals with multiple unspent outputs."]},{"l":"Token Bag","p":["The constructor of the TokenBag class initializes a new token bag with a number of tokens and an initial owner. It also sets a name and a symbol for the token bag.","The transfer function checks if there are sufficiently many tokens to send the amount. It throws an error if insufficient funds are detected. Otherwise, it decrements the number of tokens in the current bag by amount and creates a new smart object of type TokenBag that is owned by the recipient and stores the amount many tokens.","We note that calls to the transfer function do not change the overall number of tokens: when a new token bag with a number of tokens is created, that same number of tokens is removed from another object (the object on which the transfer function is called).","This is because all function calls on the Bitcoin Computer are atomic in the sense that either all instructions in a function are evaluated or none of them."]},{"l":"Adding Approval","p":["Approval is a mechanism in of the ERC20 contract where a user called spender is granted the right to spend certain number of tokens of the original owner.","We add two properties approvals and originalOwner to the TokenBag class and two methods approve and disapprove to grant and revoke approval. For now, these methods work on an all or nothing bases for all tokens in the bag."]},{"l":"BRC20","p":["In general, each user will own several token bags, in the same way that users generally own multiple unspent outputs. The BRC20 class adds functionality for sending tokens from multiple bags and for computing their balance across multiple bags. This is similar to the functionality of a traditional Bitcoin wallet.","There is plenty of room for improvement with this class: one issue is that when a payment is made from multiple bags, all payments are sent in separate transactions. In addition, the running time can be vastly improved through the use of caching. Both issues can be solved at the smart contract level and do not require any changes to the Bitcoin Computer.","Check out a working version of the BRC721 contract and a NFT application."]}]]