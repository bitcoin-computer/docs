[[{"i":"#","p":["This is a custom description for this page"]},{"l":"Bitcoin Computer","p":["Turing Complete smart contracts on Bitcoin"]},{"l":"Simple","p":["Bitcoin Computer makes it possible to run smart contracts on Bitcoin. Smart contracts are Javascript classes and you can store instances of these classes (objects) on the Bitcoin blockchain. Each object has a unique location on the blockchain and if you know the location you can read the state of the object. The state can only be updated by function calls so that constraints on data updates can be enforced.","You can build games, social networks, NFTs, fungible tokens, stable coins, exchanges, auctions, voting, office applications, artificial intelligence, every application you can think of. Building applications couldn't be simpler, just build a client side web application and whenever you want to store something in a database just use our client side lib to store an object on the blockchain. Usually the entire backend can be replaced by a smart contract which can vastly simplify development."]},{"l":"Efficient","p":["On other blockchains fees are charged for every computational step and for every memory allocation. On Bitcoin there is no fee per computational step or memory allocation. This is because smart contracts are evaluated client side as opposed to by miners. Bitcoin Computer smart contracts are lightweight and do not impose any additional effort on nodes and miners. The only fee that needs to be paid is for the block space required to encode the name of the function being called and its parameters. This is mostly less than a few cents. This makes it possible, for the first time, to run compute and memory intense programs as smart contracts."]},{"l":"Trustless","p":["You can run your own node. The node gives you trustless access to the Bitcoin Computer. Nobody can revoke your access if you have a copy of the node and the lib. You can think of a node as a universal backend that can power any application. You can run a node easily through docker.","We are launching on Litecoin. In the future we want to support all currencies in the Bitcoin family."]}],[{"l":"Examples"},{"i":"non-fungible-tokens-nfts","l":"Non-Fungible Tokens (NFTs)","p":["A non-fungible token is an object that stores an image url, the title of an artwork, and the name of a artist.","A keyword property _owners is set to a public key. The holder of that public key is the owner of the object in the sense the corresponding private key is required to update the object. To send the NFT to another user, the current owner can reassign the _owners property to the new owner's public key.","You can find a working implementation for minting, storing, and sending NFTs on Github."]},{"l":"Fungible Tokens","p":["A fungible token is initialized to a fixed supply and an initial owner.","The only function is a send function. This function checks that the supply of the token is above the amount to be sent. If so the amount stored in this instance is decreased by \"amount\". Then a new instance of the token class is created. The owner of the new token is set to the recipient.","See Github."]},{"l":"Chat","p":["A chat is an object that stores a list of messages that is initially empty. It has a function invite that adds another user to the _owners array thereby giving them write access (only the creator of the chat can post and invite users initially). Once invited a user can call post to send a message to the chat and invite other users.","Try it out on Github."]}],[{"l":"Getting Started"},{"l":"Run the Tests","p":["The easiest way to get started is to run the tests. If you get an error have a look here."]},{"i":"run-in-nodejs","l":"Run in Node.js","p":["Create file index.mjs","Then, execute the following in the same directory","If you get an error \"Insufficient balance\" you have to fund the wallet, have a look here. If the wallet is funded you will see:","You can clone the boilerplate or watch the video walkthrough"]},{"l":"Run in the Browser","p":["Create file index.js.","Create file index.html","Run the following in an empty directory and open your browser at http://localhost:1234.","More info in this video"]}],[{"l":"Troubleshooting"},{"i":"wallet-is-currently-rescanning-abort-existing-rescan-or-wait","l":"Wallet is currently rescanning. Abort existing rescan or wait.","p":["When you use a seed phrase for the first time, the Bitcoin node needs to re-scan the blockchain. This usually takes around 10m but can take up to an hour. Just wait and try again."]},{"l":"Insufficient balance in address","p":["You need to fund the wallet inside the computer object.","The Bitcoin Computer currently supports Litecoin testnet. You can get free testnet coins from a Litecoin Testnet Faucet here, here, here, or here. We recommend generating a new seed phrase through a BIP39 generator."]}],[{"l":"Getting Help","p":["If you have any questions or are having trouble writing a smart contract please get in touch. You can","ask a question in the Telegram Group","create and issue on Github","We can also help you develop a smart contract on the Bitcoin Computer. Email clemens@bitcoincomputer.io for more information."]}],[{"l":"Tutorial","p":["This tutorial explains how to build an encrypted blockchain-based chat."]},{"l":"The Computer Object","p":["The first step is to create an object computer from bitcoin-computer-lib. The computer object is a wallet that can build and broadcast Bitcoin transactions that encode smart object creations and updates. You can pass in a BIP39 seed phrase to initialize the wallet (you can generate a seed phrase here).","By default a computer object is configured to connect to Litecoin testnet through a publicly available Bitcoin Computer Node. See Section Api for details on the configuration options."]},{"l":"Smart Contracts","p":["Every Javascript (ES6) class is a smart contract. For example, a smart contract for a chat could be:"]},{"l":"Smart Objects","p":["A smart object is a Javascript object that is stored on the Bitcoin blockchain. The computer.new() method inputs a class and an array of arguments for the constructor of the class and returns a smart object from the class.","When a smart object a is created a Bitcoin transaction is broadcast that records the creation of a. One of the outputs of the transaction is the immutable representation of the smart object on the blockchain. This output is called the location of a."]},{"l":"Object Identity","p":["Each smart object a has a unique identity a._id that remains fixed throughout the lifecycle of the object. This identity is the transaction id and the output number of the location of a."]},{"l":"Object Revision","p":["Each smart object a has a revision a._rev that is changed every time the object is updated. Each version of a smart object has a unique identifier that can be used to recover every previous version of a."]},{"l":"Object Root","p":["Each smart object a has a root a._root. For a smart object a created with computer.new the root a._root of a is equal to a._id. However smart objects can also be created inside a constructor or function call on another smart object b. In this case the root of a is the root of b."]},{"l":"Updating a Smart Object","p":["Smart objects can be updated through function calls (it is not possible to assign to a property of a smart object directly). When a function is called, a transaction is broadcast that spends the output representing the smart object before the function call and creates a new unspent output (utxo) representing the object after the function call. Note that is necessary to await on function calls as broadcasting a transaction is an asynchronous operation.","It is important to note that a user can only call a function of a smart object a if that user can spend the output that stores the current state of a. This is the basis of the security model of the Bitcoin Computer."]},{"l":"Data Ownership","p":["Every smart object a contains an array a._owners of public key strings. This array can be used to restrict write access to the smart object: in order to call a function on a a user needs a private key matching one of the public keys in the a._owners array.","It is possible to reassign the a._owners property to change the ownership of a. If the property is not assigned in function calls it is unchanged and in constructor calls it defaults to the public key of the computer object that created a.","For example, in our chat, only the user that created the chat can post initially. However, we can add an invite function to the chat to allow other users to post."]},{"l":"Encryption","p":["By default the state of all smart objects is publicly visible. However, every smart object a has a property a._readers that can be used to restrict read access to a. If a._readers is set, the meta data of the current revision is encrypted so that only the specified readers can decrypt it. If the a._readers is not assigned, it remains unchanged in function calls and defaults to the public key of the computer object that created a.","For example, if we want to ensure that only people invited to the chat can read the messages, we can update our example code as follows:","A user can (only) read the state of a smart object if they have read access to the current and all previous versions of the object. It is therefore not possible to revoke access from smart objects that has already been granted. It is however possible to remove a user's ability to read the state of a smart object from a point in time forwards.","Both encryption and decryption happens securely in user's browsers. We note that while all smart contract data is encrypted flows of money are not obfuscated in order to not hinder anti money laundering efforts."]},{"l":"Finding Smart Objects","p":["The process of reading the current stat of a smart objects a consists of two steps: finding the latest revision of a and synchronizing to the revision (synchronizing will be described in the next Section)."]},{"l":"Querying by Ownership","p":["The computer.queryRevs() method returns an array of all revisions that satisfy certain conditions as specified in the parameter. For example, one can obtain all revisions owned by a public key or all revisions of a specific smart contract."]},{"l":"Querying by Identity","p":["It is often convenient to refer a smart object by its identity. In order to synchronize to the latest version of the object its latest revision is needed. The computer.getLatestRevs() function returns the latest revision of a given id.","Multiple ids can be passed in and their revisions will be returned in order."]},{"l":"Synchronizing to a Smart Object","p":["The computer.sync() method returns a smart object given a revision.","In the example of our decentralized chat, a user could first synchronize to the chat to read the messages. If the user is an owner the user can post a message."]},{"l":"Off-Chain Storage","p":["It is sometimes not the best choice to store data on chain. For example if the data is big it might be too expensive. Other data, like personal data, should never be stored on chain, not even encrypted, in order to comply with end user privacy regulation such as CCPA and GDPR.","Each smart object a has a property a._url that can be set to the url of a Bitcoin Computer Node. When this property is set the meta data that encodes an update is not stored on the blockchain but on the Bitcoin Computer Node at the given url. The blockchain contains only the hash of the meta data and a link to where the data can be obtained from.","For example, if we want to allow users to send images to the chat that are too large to be stored on chain, we can make use of the off-chain solution:","The meta data for that specific call will be stored on the Bitcoin Computer Node at https://my.node.example.com. The only data that is stored on the blockchain is the url and the hash of the data. The cost of calling postPic is therefore independent of the size of picBuf."]},{"l":"Sending and Storing Cryptocurrency","p":["Each smart object a can store an amount of cryptocurrency a._amount. The cryptocurrency is owned by the owners of the object, and each owner can send the Bitcoin to another user by reassigning the a._owners property."]}],[{"l":"Api","p":["This Api describes the class Computer that can create and synchronize to smart objects, the class DB that can read, write, and update data on the blockchain, and the class Wallet, a Bitcoin wallet."]},{"l":"Computer"},{"l":"Constructor"},{"i":"computernew","l":"computer.new()","p":["The computer.new() method creates new smart objects from a class and a list of arguments for the constructor of the class. The arguments can be basic data types or smart objects."]},{"i":"computersync","l":"computer.sync()","p":["The computer.sync() method returns the smart object stored at a given revision. For every smart object a the following invariant will be true."]},{"i":"computerqueryrevs","l":"computer.queryRevs()","p":["The computer.queryRevs() method returns an array containing the latest revisions owned by a given public key. The public keys are string encoded. If no parameter is passed to getRevs() the public key of the computer object is used.","When a key is omitted the condition is ignored. For example, if only the class is set the call will return all revision of that class regardless of the owners."]},{"i":"computergetlatestrevs","l":"computer.getLatestRevs()","p":["The computer.getLatestRevs() method inputs an id and returns the latest revision of the smart object with that id. If no smart object with that id exists an error is thrown.","After running the above code rev will be equal to a._rev if a1 is a smart object."]},{"l":"Db","p":["The recommended way to create an instance of the Db class is to create an object of the Computer class and to access its property computer.db."]},{"i":"dbput","l":"db.put()","p":["The db.put() method inputs an array of JSON objects and stores them in a transaction. Each element of the array is stored in a separate output. The method returns the array of locations of the outputs created."]},{"i":"dbget","l":"db.get()","p":["The db.get() method returns the JSON objects stored at a given array of locations."]},{"i":"dbupdate","l":"db.update()","p":["The db.update() method has two parameters: a list of locations and a list of JSON objects. It broadcasts a transaction that spends the locations and that has one output for each JSON object.","You can use db.get() to inspect the smart contract protocol. Try to call db.get()with the ids or rev of a smart object to see the data on the blockchain. Remember to pass the id inside an array likedb.get([a._ id])."]},{"l":"Wallet","p":["We recommend creating a Wallet instance by creating a Computer instance and accessing the nested wallet property.","The wallet built into Bitcoin Computer is compatible with the widely used Bitcore library. This makes it easy to integrate Bitcoin Computer into existing apps."]},{"i":"walletgetmenmonic","l":"wallet.getMenmonic()","p":["The wallet.getMnemonic() method returns a Bitcore compatible Javascript object encoding a Mnemonic. To return the mnemonic string call the toString() method."]},{"i":"walletgetpublickey","l":"wallet.getPublicKey()","p":["The wallet.getPublicKey() method returns a Bitcore compatible Javascript object encoding a public key. To return the public key in string encoding call the toString() method."]},{"i":"walletgetaddress","l":"wallet.getAddress()","p":["The wallet.getAddress() method returns a Bitcore compatible Javascript object encoding a Bitcoin address. To return the address in string encoding call the toString() method."]},{"i":"walletgetbalance","l":"wallet.getBalance()","p":["The wallet.getBalance() method returns the current balance in satoshi."]},{"i":"walletsend","l":"wallet.send()","p":["The wallet.send() method sends an amount of satoshi to an address."]}],[{"l":"Api","p":["Docs coming soon."]}],[{"l":"Tutorial","p":["Docs coming soon.","For now have a look at the readme of the npm package."]}],[{"l":"Wallet","p":["A wallet allows a user to check their balance and to build a transaction to send cryptocurrency to another user.","A Bitcore-style library can be used to build the transaction. Bitcoin Computer Lib can be used to provide data to the wallet and to broadcast the transaction. A BIP39 mnemonic sentence can be used to generate a bitcoin computer wallet.","Computing the balance is a two step process. The first step is to find all the unspent transaction outputs (utxos) of the address. The utxos store the cryptocurrency. The second step is to sum up the satoshis in the utxos.","The easy way to implement the send function is to use the Bitcoin Computer wallet."]},{"l":"The Hard Way","p":["It is also possible to use the Bitcoin Computer and a Bitcore style library to build a transaction directly. This is interesting because the smart contract for a fungible token is conceptually similar to the code used to build a wallet.","The first step is to query for all utxos. We add inputs to the transactions that spend the utxos until we have enough to cover the amount. We then add the output to create a new utxo that the receiver can spend. The last thing left to do it to sign and braodcast the transaction.","The \"More Examples\" Section is under construction. We are using it to refine our api so some features ( computer.getUtxos and computer.broadcast) are not supported yet. See the Api for a list of currently supported features."]}],[{"l":"Fungible Token","p":["We explore how an ERC20 style contracts (as defined in EIP20) can be built on Bitcoin. We use two classes, a TokenBag can stores tokens and has a send function. The ERC20 class makes it possible to deal with multiple token bags in the same way that a wallet deals with multiple unspent outputs."]},{"l":"Token Bag","p":["The constructor of the TokenBag class stores the number of tokens an the initial owner. The send function first checks if there are sufficient funds. If so it creates a new smart object that sends the required number of tokens to the recipient."]},{"l":"Adding Approval","p":["Approval is a mechanism in of the ERC20 contract where a user called spender is granted the right to spend certain number of tokens of the original owner.","We add two properties approvals and originalOwner to the TokenBag class and two methods approve and disapprove to grant and revoke approval. For now these methods work on an all or nothing bases for all tokens in the bag. We also add two propertied name and symbol according to the ERC20 standard."]},{"l":"BRC20","p":["In general each user will own several token bags, in the same way that users generally own multiple unspent outputs. The BRC20 class adds functionality for sending tokens from multiple bags and for computing their balance across multiple bags. This is similar to the functionality of a traditional Bitcoin wallet.","We note that it is not necessary to check a message sender","This is a work in progress and some functions are missing. There is also a partial implementation on Github."]}]]