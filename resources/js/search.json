[[{"i":"#","p":["This is a custom description for this page"]},{"l":"Bitcoin Computer","p":["A smart contract system for UTXO-based blockchains. Key features include:","Low fees through client-side validation","Cost independent of time and space complexity","Smart contract programming in Javascript and Typescript","Access to all historical states","Built-in privacy through encryption","Efficient block space usage with off-chain storage","ES6 module system","Pure and secure, no need for a side-chain","Support for Litecoin with support for Bitcoin and Dogecoin coming soon.","With these features, you can build a variety of decentralized applications, such as tokens, exchanges, games, social networks, and more."]},{"l":"Get Started","p":["Bitcoin Computer"]},{"l":"Examples","p":["To run an example have a look at the README.md file in the corresponding folder."]},{"l":"Applications","p":["Wallet: A minimal non-custodial wallet","Chat: A p2p chat application where messages are communicated over the blockchain","Fungible Token: An application for minting, sending, and storing fungible tokens","Non Fungible Token: An application for minting, sending, and storing non-fungible tokens (NFTs)"]},{"l":"Standard Smart Contracts","p":["BRC20 contract: A implementation of the ERC20 Fungible Token Standard","BRC721 contract: A implementation of the ERC721 Non-Fungible Token Standard"]},{"l":"Templates","p":["Bitcoin Computer Node.js Template: A template for starting a new Bitcoin Computer application with node.js","Bitcoin Computer React Template: A template for starting a new Bitcoin Computer application with Create React App"]},{"l":"Core Library","p":["The core smart contract library is based on two packages:","Bitcoin Computer Lib A non-custodial web wallet for reading and writing smart contracts","Bitcoin Computer Node Server side infrastructure for providing trustless access to smart contracts"]},{"l":"Price","p":["It is free to develop and test a Bitcoin Computer application on testnet and regtest.","On Mainnet the fees for using the Bitcoin Computer are on average the same as the transaction fees charged by miners fees. For example, if the miner transaction fee is one cent, then you pay two cent in total: one cent to the miners, and one cent to support the development of the Bitcoin Computer."]},{"l":"Development Status","p":["We have completed two internal audits and addressed any discovered issues. Currently, there are no known security vulnerabilities, however, it is possible that unknown vulnerabilities may exist. We plan to conduct one more thorough internal security audit prior to recommending the usage of the Bitcoin Computer in production environments."]},{"l":"Getting Help","p":["If you have any questions, please let us know in our Telegram group, on Twitter, or by email clemens@bitcoincomputer.io."]},{"l":"License","p":["Bitcoin Computer Lib and Bitcoin Computer Node are licensed under the Creative Commons Attribution-NoDerivs 3.0 Unported License. All other packages in this monorepo are licensed under the MIT License. See the individual packages for more information."]}],[{"l":"Start","p":["If you are trying out the Bitcoin Computer for the first time, or you want to integrate it into a new or existing application, we recommend to follow the readme file of the Bitcoin Computer Library.","Bitcoin Computer Library"]},{"l":"Run a Node","p":["You can run a Bitcoin Computer Node through docker. You need to run a node if you want to run an application on mainnet. It also offers a great development experience.","Bitcoin Computer Node"]},{"l":"Host an Application","p":["You can run one of the example applications by cloning the monorepo.","Bitcoin Computer Monorepo"]}],[{"l":"Tutorial"},{"l":"Write a Smart Contract","p":["Smart contracts are Javascript classes that extend from Contract. For example, a smart contract for a chat could be:","Smart contracts are mostly just Javascript classes. One distiction is that it is not possible to assign to this in constructors. Instead you can initialize a smart object by passing an argument into super as shown above."]},{"l":"Create a Wallet","p":["You can create a smart contract wallet from the Bitcoin Computer library.","You can pass in a BIP39 mnemonic to initialize the wallet. To generate a fresh mnemonic click here. You can find more wallet configuration options here."]},{"l":"Create a Smart Object","p":["The computer.new function can be used to create a smart object from a smart contract. For example","When this call is executed, a transaction is broadcast that contains both the source code of Chat as well as the expression new Chat('hello'). The object a that is returned has all the properties defined in the class, and five extra properties _id, _rev, _root, _owners and _amount.","The additional properties are explained in detail in the Protocol. For now it is sufficient to know that 667c...2357 is the transaction id of the transaction that contains the expression `${Chat} new Chat('hello')`. The property _owners is an array of public keys that are allowed to update the object. The property _amount is the amount of satoshis that are stored in the object."]},{"l":"Read a Smart Object","p":["The computer.sync function computes the state of smart object from the metadata on the blockchain. For example, synchronizing to 667c...2357:0 it will return an object with the same value as a.","Reading and writing can be performed to different users. The blockchain allows any two users to obtain consensus over the state of smart objects. This makes it possible to build decentralized applications."]},{"l":"Update a Smart Object","p":["Smart objects can only be updated through function calls. As function calls are recorded in Bitcoin transactions it is necessary to await on function calls.","Note that _rev has been update but that _id and _root stayed the same. Every time a smart object is updated a new revision is created and assigned to the _rev property. Revisions allow you to reconstruct each historical state of an object."]},{"l":"Find a Smart Object","p":["The computer.query function provides several ways of finding the latest revision of a smart object.","A basic pattern for many applications is to identify smart objects by their id, look up their latest revision using computer.query and then to compute their current state using computer.sync. For example, in a chat, we might have the url for the chat containing the id of the chat object. We could then recover the latest state of the chat as follows:"]},{"l":"Data Ownership","p":["Every smart object can have up to three owners. Only an owner can update the object. The owners can be set by assigning string encoded public keys to the _owners property of a smart object. If the _owners property is not assigned in a smart contract it defaults to the public key of the computer object that created the smart object.","In the chat example the initial owner is the user that created the chat with computer.new. Thus only this user will be able to post to the chat. We can add a function to update the owners array to invite more guests to chat."]},{"l":"Privacy","p":["By default, the state of all smart objects is public. However, you can restrict read access to an object by setting a property _readers. If _readers is assigned to an array of public keys, the meta-data of the current revision is encrypted in a way that only the specified readers can decrypt it.","For example, if we want to ensure that only people invited to the chat can read the messages, we can update our example code as follows:","A user can (only) read the state of a smart object if they have read access to the current and all previous versions of the object. It is, therefore, not possible to revoke access to a revision. However, it is possible to remove a user's ability to read the state of a smart object from a point in time forwards.","Both encryption and decryption happen securely in users' browsers. We note that while all smart contract data is encrypted, flows of money are not obfuscated in order not to hinder anti-money laundering efforts."]},{"l":"Saving Block Space","p":["Not all data needs to be stored on the blockchain. For example, personal data should never be stored on chain, not even encrypted.","When the property _url of a smart object is set to the URL of a Bitcoin Computer Node, the corresponding metadata is stored on the specified Bitcoin Computer Node. The blockchain only contains a hash of the meta data and a link to where it can be retrieved.","For example, if we want to allow users to send images that are too large to be stored on chain to the chat, we can make use of the off-chain solution:"]},{"l":"Cryptocurrency","p":["Each smart object can store an amount of satoshi. By default a smart object stores a minimal (non-dust) amount. If the _amount property of a smart object is set to a number, the output storing that smart object will contain that number of satoshis. For example, consider the class Payment below.","If a user A wants to send 210.000 satoshis to a user B, the user A can setup the payment as follows:","When the payment smart object is created, the wallet inside the computerA object funds the 210.000 satoshi that are stored in the payment object. Once B becomes aware of the payment, he can withdraw by syncing against the object and calling the cashOut function."]}],[{"l":"Protocol","p":["The Bitcoin Computer protocol records the execution of Javascript programs in Bitcoin transactions. The objects created by these programs can be associated with the outputs of the transactions with spent outputs representing historical states and unspent outputs representing the current state. Both the historical and current states of the smart objects can be computed from the metadata on the blockchain. This way all users can gain consensus over the states of these objects resulting in the creation of a global shared memory.","Just like you can use a programming language without knowing in detail how it is evaluated, you can use the Bitcoin Computer without understanding it's protocol. However if you are interested in how smart contracts work on Bitcoin, you can find more information below."]},{"l":"The Global Shared Memory","p":["Allocation and de-allocation in the global shared memory can be encoded as follows:","The n-th output of a transaction with m inputs is called","a memory update if n <= m","a memory allocation if m < n","A memory de-allocation is an input at index n in a transaction with m < n outputs","We can assign two names, \"revisions\" and \"ids\", to all outputs: The revision of an output is the concatenation of its transaction id and output number. The id of an output is it's revision if the output is a memory allocation. If an output o is a memory update then the transaction contains an input i with the same index of o. In this case o's revision is the revision of the output being spent by i."]},{"l":"Smart Contracts","p":["Smart contracts can be build on top of the shared global memory using the Bitcoin Computer protocol. A Bitcoin Computer Transaction is a Bitcoin transaction that contains the following metadata:","A Javascript expression, such as new Counter() or counter.inc(), which may contain free variables like counter.","A blockchain environment object that associates the free variables in the expression with the inputs of the transaction.","An optional module specifier, which identifies a transaction output storing a module.","The computer.sync function computes an Javascript object for each output of a Bitcoin Computer transaction. The object is annotated with the id and revision of the cell in global memory that stores the object. Such an object is called a smart object."]},{"l":"Keyword Properties","p":["In addition to the properties defined in the class that a smart object is created from, it has the following properties:","_id: Refers to the transaction output that allocated the memory cell that stores the smart object. This id remains constant, even if the object is updated.","_rev: Refers to the last transaction output that updated the smart object. It is updated every time the object is updated.","_root: For an object created using computer.new, the _ root is equal to its _ id. If an object is created within a function call, the _ root of the new object is the _ root of the object on which the function was called.","_amount: Indicates the amount of cryptocurrency (in satoshi) stored in the smart object.","_owners: An array of string-encoded public keys representing the owners of the object. Only the owners can update a smart object by calling one of its functions."]},{"l":"Calling Constructors","p":["To allocate a memory cell and to store a new smart object in it, a transaction that contains a Javascript expression e 1; e 2... e n where e n is of the form new C(...) must be broadcast. The class C can be defined in the expression or it can be passed in from a module.","The function computer.sync computes Javascript objects from outputs as shown in the figure. Note that _id, _rev, and _root are all set to the same output."]},{"l":"Calling Functions","p":["To update a smart object stored in the shared global memory, a Bitcoin transaction must be broadcast that includes a Javascript expression of the form of x.f(...). To determine which memory cell the free variable x is stored in, the blockchain environment must associate x with an input. In the example this input is shown as nft.","The transaction will create corresponding outputs to these inputs, which represent the updated state of the memory cells. These outputs are called the revisions of a smart object, and the most recent revision is stored in the _rev property of the smart object.","The computer.sync function can be called with each revision of a smart object. This provides access to all historical states of a smart object."]},{"l":"Returning Objects","p":["When a function call on a smart object returns a value of type object, a new memory cell is allocated to store the returned value.","The figure below illustrates the minting and sending of 100 fungible tokens. The blue user, with public key 03a1d..., mints the tokens in the first transaction, producing one output that represents the 100 newly minted tokens. The second transaction represents the distribution of tokens after the blue user sends 3 tokens to the green user, with public key 03f0b....","The blue output of the second transaction represents the 97 tokens that the blue user still holds, while the green output represents the three tokens now owned by the green user. The _ root property of both outputs in the second transaction is linked to the output of the first transaction, as the memory cell for the three tokens was allocated within a function call.","This setup prevents forgery, as any two tokens with the same root can be traced back to the same mint. To mint a second token with the same root, one would have to broadcast a transaction with the transaction id of the first transaction, which is impossible."]}],[{"l":"API","p":["This section outlines the API for the Computer class, which allows for the creation and storage of smart objects on the blockchain. It also enables querying for the location of these objects and calculating their latest values. The Computer class serves as the primary interface for the Bitcoin Computer API."]},{"l":"Basic"},{"l":"Constructor","p":["The \"Computer\" class constructor creates objects capable of creating smart contract transactions as well as standard payments. Each such object is connected to a Bitcoin or Litecoin node and can broadcast transactions and access blockchain information. The constructor parameters are optional and can be used to specify the target blockchain, network, and wallet."]},{"l":"new","p":["This method creates new smart objects. The parameters are a class, a list of arguments for the constructor of the class and a module specifier. The arguments can be of basic data type or smart objects.","Here a Location is the type","If you call a function of a smart object, the call is recorded in a transaction. The transaction is signed by the wallet associated to the computer object and broadcast to Bitcoin Computer Node. The call returns a promise that resolves to the result of the function call. See the Tutorial for an example."]},{"l":"query","p":["Returns an array of strings, containing the latest revisions of smart objects that satisfy certain conditions. For example, one can obtain all revisions owned by a public key or all revisions of a specific smart contract.","When a key is omitted, the condition is ignored. For example, if only class is set in the contract parameter, the call will return all revisions of that class regardless of the owners."]},{"l":"sync","p":["This returns the smart object stored at a given revision."]},{"l":"Advanced","p":["Most smart contracts can be implemented using the basic methods. However, the following methods can be used to implement more complex contracts that use for example off-chain signing or server-side funding."]},{"l":"encode","p":["Encodes an expression, an environment and a module specifier into a Bitcoin transaction of type Transaction as in the Bitcore Library."]},{"l":"decode","p":["Converts a Bitcore transaction into a transition object. The inverse of encode."]},{"l":"encodeNew","p":["Encodes a smart object creation into a Bitcoin transaction."]},{"l":"encodeCall","p":["Encodes a smart object call into a Bitcoin transaction that can be broadcast to the Bitcoin mining network."]},{"l":"Modules"},{"l":"export","p":["To optimize blockchain storage and reduce transaction costs, consider exporting your modules. This separates the modules from your smart objects, enabling the code for a class to be stored just once. The process of funding, signing, and broadcasting a transaction will be explained later in the text."]},{"l":"import","p":["Imports a smart contract from a module specifier. Future versions of the library will support importing modules from within an expression. For now, you can import modules from the blockchain using the revision as described in the previous section."]},{"l":"Wallet"},{"l":"fund","p":["Funds a Bitcoin transaction with UTXOs from the wallet."]},{"l":"sign","p":["Signs a Bitcore transaction with the private key of the wallet. The transaction needs to be fully funded before it can be signed. If multiple parties are involved in the transaction, each party needs to sign the transaction before it can be broadcasted."]},{"l":"broadcast","p":["Broadcasts a Bitcoin transaction to the Bitcoin mining network."]},{"l":"send","p":["Sends an amount of satoshis to an address."]},{"l":"rpcCall","p":["Calls a Bitcoin RPC method with the given parameters."]},{"l":"getAddress","p":["Returns a string encoding Bitcoin address."]},{"l":"getBalance","p":["Returns the current balance in satoshi."]},{"l":"getPublicKey","p":["Returns a string encoding a public key."]},{"l":"getChain","p":["Returns the chain of the computer object."]},{"l":"getNetwork","p":["Returns the network of the computer object."]},{"l":"getMenmonic","p":["Returns a string encoding a BIP32 mnemonic sentence of the computer object."]},{"l":"getPassphrase","p":["Returns the passphrase of the computer object."]},{"l":"getPrivateKey","p":["Returns a string encoding a private key."]},{"i":"getpublickey-1","l":"getPublicKey","p":["Returns a string encoding a public key."]},{"l":"getUtxos","p":["Returns an array of UTXOs."]}],[{"l":"Ordinals","p":["Ordinal support is still experimental.","Ordinals is a scheme for assigning names to satoshis. These names can be linked to digital assets to make them transferrable.","The Global Share Memory protocol is closely related to the ordinals protocol. It is based on a scheme for assigning names to outputs instead of to satoshis. The purpose is the same, an asset can be linked to a name, thereby making the asset transferrable.","There is an important special case where the two protocol coincide: Recall that an output is a \"memory update\" if its index is smaller than the number of inputs of the transaction. We call a memory update conservative if it stores the same amount of satoshis as the output that it spends. Conservative updates preserve ordinal ranges.","A Bitcoin Computer smart contract that does not use the _amount keyword only produces conservative updates. Therefore a smart objects defined by such smart contracts preserve ordinal ranges."]},{"l":"Example","p":["For example consider an NFT contract:","If you create an NFT it will be stored in an output and that output is identified by the revision of the smart object. Say that output contains ordinals 5-10 (we are assuming some OrdinalsApi that can return the ordinals stores in a specified output).","If we send the NFT it will get a new revision assigned. The important thing is that the new revision will have exactly the same ordinal range.","Therefore you can build smart contracts like swaps that cannot be built with ordinals alone. You can store ordinals inside a smart object, pass them around in smart contracts and safely recover them, for example after they have been exchanged.","It is important to note that ordinal ranges are only preserved in smart contracts that do not use the _amount keyword."]}],[{"l":"Wallet","p":["A wallet allows a user to check their balance and make a transaction to send cryptocurrency to another user.","In order to build the transaction, we can use a Bitcore-style library. Bitcoin Computer Lib can provide data to the wallet and broadcast the transaction. A BIP39 mnemonic sentence can be employed to generate a Bitcoin Computer wallet.","You can use the computer object to calculate the balance of a given address.","The easy way to send money to a friend is to use the send function:","Check out a working version on Github"]}],[{"l":"Chat","p":["The Bitcoin Chat presented here is a hackable chat that runs on the blockchain. The chat does not need a database backend because all data is stored on the blockchain (currently runs on LTC testnet). The interface between the chat and the blockchain is provided by Bitcoin Computer.","The Chat class has a constructor and two functions, post and invite.","The constructor initializes a owner of the chat and an empty messages array. The post function stores the new messages, and the invite function records the users who join the chat.","Check out a working version on Github."]}],[{"l":"Non-Fungible Token","p":["Let's explore how ERC721 style non-fungible token (NFT) contracts can be implemented on Bitcoin.","In the NFT class, we have a constructor and a send function. The constructor initializes a new token with a url and an initial owner. The send function adds the new owner to the list of owners of this token."]},{"l":"BRC721","p":["BRC721 is the ERC721 standard built on Bitcoin. It currently implements the IBRC721 interface.","The BRC721 class has the following functions: mint, balanceOf, ownerOf, and transfer. The mint function mints a new non-fungible token. It first checks whether or not there is a masterNFT. If not, and a name and a symbol are inputted, the computer generates a new NFT, which includes the name and symbol and a new owner's information, and sets it as this BRC721's masterNFT. If there's already a masterNFT, but its name does not match the name inputted, or the symbol does not match, throw an error. Otherwise, the masterNFT will mint a new token with the new owner's information.","The balanceOf function returns the number of NFTs the user owns. The ownerOf function returns the owner of a given token ID. The transfer function allows you to send the token to another user.","Check out a working version of the BRC721 contract and a NFT application."]}],[{"l":"Fungible Token","p":["We explore how ERC20 style fungible token contracts can be built on Bitcoin. The BRC20 class implements the interface described in EIP20.","We use two classes: a TokenBag encapsulates the minimal amount of data that needs to be stored on the blockchain. A token bag can be thought of as the equivalent to unspent transaction output (utxo) in the token world: while a utxo stores a number of satoshi, a token bag stores a number of tokens. The ERC20 class helps manage multiple token bags, in the same way that a wallet deals with multiple unspent outputs."]},{"l":"Token Bag","p":["The constructor of the TokenBag class initializes a new token bag with a number of tokens and an initial owner. It also sets a name and a symbol for the token bag.","The transfer function checks if there are sufficiently many tokens to send the amount. It throws an error if insufficient funds are detected. Otherwise, it decrements the number of tokens in the current bag by amount and creates a new smart object of type TokenBag that is owned by the recipient and stores the amount many tokens.","We note that calls to the transfer function do not change the overall number of tokens: when a new token bag with a number of tokens is created, that same number of tokens is removed from another object (the object on which the transfer function is called).","This is because all function calls on the Bitcoin Computer are atomic in the sense that either all instructions in a function are evaluated or none of them."]},{"l":"Adding Approval","p":["Approval is a mechanism in of the ERC20 contract where a user called spender is granted the right to spend certain number of tokens of the original owner.","We add two properties approvals and originalOwner to the TokenBag class and two methods approve and disapprove to grant and revoke approval. For now, these methods work on an all or nothing bases for all tokens in the bag."]},{"l":"BRC20","p":["In general, each user will own several token bags, in the same way that users generally own multiple unspent outputs. The BRC20 class adds functionality for sending tokens from multiple bags and for computing their balance across multiple bags. This is similar to the functionality of a traditional Bitcoin wallet.","There is plenty of room for improvement with this class: one issue is that when a payment is made from multiple bags, all payments are sent in separate transactions. In addition, the running time can be vastly improved through the use of caching. Both issues can be solved at the smart contract level and do not require any changes to the Bitcoin Computer.","Check out a working version of the BRC721 contract and a NFT application."]}]]