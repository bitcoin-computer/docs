[[{"i":"#","p":["This is a custom description for this page"]},{"l":"Bitcoin Computer","p":["Lightweight smart contracts on Bitcoin and Litecoin \uD83C\uDF89"]},{"l":"Simple","p":["The Bitcoin Computer makes it possible to run smart contracts on UTXO-based blockchains like Bitcoin, Litecoin, or Dogecoin. You can write smart contracts in JavaScript and store instances of the smart contracts (called smart objects) on a UTXO-based blockchain. Each smart object has one or more owners who can update the smart object through function calls. Each smart object also has a unique identifier and anyone can read the latest state of the smart object if they know the identifier.","You can build games, social networks, NFTs, fungible tokens, stable coins, exchanges, auctions, voting systems, decentralized key-value stores, office applications, artificial intelligence, and any other application you can think of. Building applications is simple because our smart contracts, written in JavaScript, integrate seamlessly into web applications."]},{"l":"Efficient","p":["On most smart contract systems fees are charged for every computational step and for every memory allocation or update. Bitcoin has always had a free computation sub set of the general purpose smart contracts set, called colored coins. This free computation is due to the fact that smart contracts are evaluated by users client-side, instead of by miners. Bitcoin Computer smart contracts are lightweight as they do not impose any additional work on miners, node operators, or other users.","The only fee that needs to be paid is the mining fee plus a Bitcoin Computer fee that is equal to the mining fee. The fixed fee makes it possible to run, compute and memory allocate intense programs as smart contracts."]},{"l":"Trustless","p":["You can run your own node and direct our client side library to it. The node gives you trustless access to the Bitcoin Computer. Nobody can revoke your access if you have a copy of the node and the lib. You can think of a node as a universal backend that can power any application.","We launched at the Litecoin Summit on October 21st \uD83D\uDE80","Check out our code with working examples on Github."]}],[{"l":"Start","p":["The code consists of a client side library ( lib) and server side library ( node). By default, lib connects to an instance of a node we are running but you can run your own node and point lib to it. You can find examples in the monorepo."]},{"l":"Run the Tests","p":["The easiest way to get started is to run the tests. If you get an error, have a look here."]},{"i":"run-in-nodejs","l":"Run in Node.js","p":["Create the file index.mjs.","Then, execute the following in the same directory.","If you get an error Insufficient balance, you have to fund the wallet; have a look here. If the wallet is funded, you will see:","You can clone the boilerplate or watch the video walkthrough."]},{"l":"Run in the Browser","p":["Create the file index.js.","Create the file index.html.","Run the following in an empty directory and open your browser at the defaults http://localhost:8080.","See the readme file of the Bitcoin Computer Monorepo."]},{"l":"Troubleshooting"},{"i":"wallet-is-currently-rescanning-abort-existing-rescan-or-wait","l":"Wallet is currently rescanning. Abort existing rescan or wait.","p":["When you use a seed phrase for the first time, the Bitcoin node needs to re-scan the blockchain. This usually takes around 10 minutes but can take up to an hour. Please wait and try again."]},{"l":"Insufficient balance in address","p":["You need to fund the wallet inside the computer object.","The Bitcoin Computer currently supports Litecoin testnet. You can get free testnet coins from a Litecoin Testnet Faucet here, here, here, or here. We recommend generating a new seed phrase through a BIP39 generator."]},{"l":"Getting Help","p":["If you have any questions or are having trouble writing a smart contract, please get in touch. You can","ask a question in the Telegram Group","create and issue on Github","get in touch on Twitter","We can also help you develop a smart contract on the Bitcoin Computer. Email clemens@bitcoincomputer.io for more information."]}],[{"l":"Wallet","p":["A wallet allows a user to check their balance and make a transaction to send cryptocurrency to another user.","In order to build the transaction, we can use a Bitcore-style library. Bitcoin Computer Lib can provide data to the wallet and broadcast the transaction. A BIP39 mnemonic sentence can be employed to generate a Bitcoin Computer wallet.","You can use the computer object to calculate the balance of a given address.","The easy way to send money to a friend is to use the send function:","Check out a working version on Github"]}],[{"l":"Chat","p":["The Bitcoin Chat presented here is a hackable chat that runs on the blockchain. The chat does not need a database backend because all data is stored on the blockchain (currently runs on LTC testnet). The interface between the chat and the blockchain is provided by Bitcoin Computer.","The Chat class has a constructor and two functions, post and invite.","The constructor initializes a owner of the chat and an empty messages array. The post function stores the new messages, and the invite function records the users who join the chat.","Check out a working version on Github."]}],[{"l":"Non-Fungible Token","p":["Let's explore how ERC721 style non-fungible token (NFT) contracts can be implemented on Bitcoin.","In the NFT class, we have a constructor and a send function. The constructor initializes a new token with a url and an initial owner. The send function adds the new owner to the list of owners of this token."]},{"l":"BRC721","p":["BRC721 is the ERC721 standard built on Bitcoin. It currently implements the IBRC721 interface.","The BRC721 class has the following functions: mint, balanceOf, ownerOf, and transfer. The mint function mints a new non-fungible token. It first checks whether or not there is a masterNFT. If not, and a name and a symbol are inputted, the computer generates a new NFT, which includes the name and symbol and a new owner's information, and sets it as this BRC721's masterNFT. If there's already a masterNFT, but its name does not match the name inputted, or the symbol does not match, throw an error. Otherwise, the masterNFT will mint a new token with the new owner's information.","The balanceOf function returns the number of NFTs the user owns. The ownerOf function returns the owner of a given token ID. The transfer function allows you to send the token to another user.","Check out a working version of the BRC721 contract and a NFT application."]}],[{"l":"Fungible Token","p":["We explore how ERC20 style fungible token contracts can be built on Bitcoin. The BRC20 class implements the interface described in EIP20.","We use two classes: a TokenBag encapsulates the minimal amount of data that needs to be stored on the blockchain. A token bag can be thought of as the equivalent to unspent transaction output (utxo) in the token world: while a utxo stores a number of satoshi, a token bag stores a number of tokens. The ERC20 class helps manage multiple token bags, in the same way that a wallet deals with multiple unspent outputs."]},{"l":"Token Bag","p":["The constructor of the TokenBag class initializes a new token bag with a number of tokens and an initial owner. It also sets a name and a symbol for the token bag.","The transfer function checks if there are sufficiently many tokens to send the amount. It throws an error if insufficient funds are detected. Otherwise, it decrements the number of tokens in the current bag by amount and creates a new smart object of type TokenBag that is owned by the recipient and stores the amount many tokens.","We note that calls to the transfer function do not change the overall number of tokens: when a new token bag with a number of tokens is created, that same number of tokens is removed from another object (the object on which the transfer function is called).","This is because all function calls on the Bitcoin Computer are atomic in the sense that either all instructions in a function are evaluated or none of them."]},{"l":"Adding Approval","p":["Approval is a mechanism in of the ERC20 contract where a user called spender is granted the right to spend certain number of tokens of the original owner.","We add two properties approvals and originalOwner to the TokenBag class and two methods approve and disapprove to grant and revoke approval. For now, these methods work on an all or nothing bases for all tokens in the bag."]},{"l":"BRC20","p":["In general, each user will own several token bags, in the same way that users generally own multiple unspent outputs. The BRC20 class adds functionality for sending tokens from multiple bags and for computing their balance across multiple bags. This is similar to the functionality of a traditional Bitcoin wallet.","There is plenty of room for improvement with this class: one issue is that when a payment is made from multiple bags, all payments are sent in separate transactions. In addition, the running time can be vastly improved through the use of caching. Both issues can be solved at the smart contract level and do not require any changes to the Bitcoin Computer.","Check out a working version of the BRC721 contract and a NFT application."]}],[{"l":"Tutorial","p":["This tutorial explains how to build an encrypted blockchain-based chat. You can download the code from Npm or Github."]},{"l":"The Computer Object","p":["The first step is to create an object computer from @bitcoin-computer/lib. The computer object is a wallet that can build and broadcast Bitcoin transactions, which encode smart object creations and updates. You can pass in a BIP39 seed phrase to initialize the wallet. (To generate a seed phrase, check this out.)","By default, a computer object is configured to connect to Litecoin testnet through a publicly available Bitcoin Computer Node. See Section API for details on the configuration options."]},{"l":"Smart Contracts","p":["Every Javascript (ES6) class is a smart contract. For example, a smart contract for a chat could be:"]},{"l":"Smart Objects","p":["A smart object is a Javascript object that is stored on the Bitcoin blockchain. The computer.new() method inputs a class and an array of arguments for the constructor of the class, and then returns a smart object from the class.","When a smart object a is created, a Bitcoin transaction is broadcasted, which records the creation of a. One of the outputs of the transaction is the immutable representation of the smart object on the blockchain. This output is called the location of a."]},{"l":"Keyword properties","p":["Each smart object has some immutable properties that are used to identify and update the object, and other properties that can be changed by the user."]},{"l":"Identity","p":["Each smart object a has a unique immutable identity a._id that remains fixed throughout the lifecycle of the object. This identity includes the transaction id and the output number of the location of a."]},{"l":"Revision","p":["Each smart object a has a revision a._rev that automatically changes every time the object is updated. Each version of a smart object has a unique identifier that can be used to recover every previous version of a."]},{"l":"Root","p":["Each smart object a has a root a._root. For a smart object a created with computer.new, the root a._root of a is equal to a._id. However, smart objects can also be created inside a constructor or a function call on another smart object b. In this case, the root of a is the root of b. The root property is immutably computed."]},{"l":"Amount","p":["Each smart object a has an amount a._amount. This is the amount of cryptocurrency that is spent to create the smart object. The amount is set to a minimal non dust value by default, but it can be changed by the user."]},{"l":"Owners","p":["Each smart object a has an array of owners a._owners. This array contains the public keys of the users that can update the smart object. The owners are set to the public key of the computer object that creates the smart object by default, but it can be changed by the user. See Section Data Ownership for details."]},{"l":"Readers","p":["Each smart object a has an array of readers a._readers. This array contains the public keys of the users that can read the smart object. If a._readers is set, the meta-data of the current revision is encrypted so that only the specified readers can decrypt it. If a._readers is not assigned, it remains unchanged in function calls and defaults to the public key of the computer object that creates a. See Section Encryption for details."]},{"l":"Url","p":["Each smart object a can have a url a._url property. Each smart object a has a property a._url that can be set to the url of a Bitcoin Computer Node. When this property is set, the meta data that encodes an update is not stored on the blockchain but on the Bitcoin Computer Node at the given url. The blockchain contains only the hash of the meta data and a link to where the data can be obtained. See Section Off-chain Storage for details."]},{"l":"Updating a Smart Object","p":["Smart objects can be updated through function calls (because it is not possible to assign to a property of a smart object directly). When a function is called, the output representing the smart object before the function call is spent, and a new unspent output (UTXO) representing the object after the call is created; this transaction is then broadcasted. Note that it is necessary to await on function calls as broadcasting a transaction is an asynchronous operation.","It is important to note that a user can call the function of a smart object a only if that user can spend the output that stores the current state of a. This is the basis of the security model of the Bitcoin Computer."]},{"l":"Data Ownership","p":["Every smart object a contains an array a._owners of public key strings. This array can be used to restrict write access to the smart object: in order to call a function on a, a user needs a private key matching one of the public keys in the a._owners array.","It is possible to reassign the a._owners property to change the ownership of a. If the property is not assigned in function calls, it is unchanged; in constructor calls, it defaults to the public key of the computer object that creates a.","For example, in our chat, only the user that creates the chat can post initially. However, we can add an invite function to the chat to allow other users to post."]},{"l":"Encryption","p":["By default, the state of all smart objects is publicly visible. However, every smart object a has a property a._readers that can be used to restrict read access to a. As explained above, if a._readers is assigned, the meta-data of the current revision is encrypted in a way that only the specified readers can decrypt it. If a._readers is not set, it remains unchanged during function calls and defaults to the public key of the \"computer\" object that created a.","For example, if we want to ensure that only people invited to the chat can read the messages, we can update our example code as follows:","A user can (only) read the state of a smart object if they have read access to the current and all previous versions of the object. It is, therefore, not possible to revoke access that has already been granted from smart objects. However, it is possible to remove a user's ability to read the state of a smart object from a point in time forwards.","Both encryption and decryption happen securely in users' browsers. We note that while all smart contract data is encrypted, flows of money are not obfuscated in order not to hinder anti-money laundering efforts."]},{"l":"Finding Smart Objects","p":["The process of reading the current state of a smart objects a consists of two steps: finding the latest revision of a and synchronizing to the revision (synchronizing will be described in the next section)."]},{"l":"Querying by Ownership","p":["The computer.query() method returns an array of all revisions that satisfy certain conditions as specified in the parameter. For example, one can obtain all revisions owned by a public key or all revisions of a specific smart contract.","It is often convenient to refer to a smart object by its identity. In order to synchronize to the latest version of the object, its latest revision is needed. You can query for the latest revision of a given id.","Multiple ids can be passed in, and their revisions will be returned in that order."]},{"l":"Synchronizing to a Smart Object","p":["The computer.sync() method returns a smart object given a revision.","In the example of our decentralized chat, a user can first synchronize to the chat to read the messages. If the user is an owner, then the user can post a message."]},{"l":"Off-Chain Storage","p":["It is sometimes not the best choice to store data on the blockchain. For example, if there's a large amount of data, it might be too expensive. Other data, like personal data, should never be stored on chain, not even encrypted, in order to comply with end user privacy regulations, such as CCPA and GDPR.","The property a._url of each smart object can be used to specify the URL of a Bitcoin Computer Node. When this property is set, the meta data that encodes an update is not recorded on the blockchain, but instead is stored on the specified Bitcoin Computer Node. The blockchain only contains a hash of the meta data and a link to where it can be retrieved.","For example, if we want to allow users to send images that are too large to be stored on chain to the chat, we can make use of the off-chain solution:","The meta data for that specific call will be stored on the Bitcoin Computer Node at https://my.node.example.com. The only data that is stored on the blockchain is the url and the hash of the data. The cost of calling postPic is thus independent of the size of picBuf."]},{"l":"Sending and Storing Cryptocurrency","p":["Each smart object can store an amount of cryptocurrency. By default a smart object stores a minimal (non-dust) amount. The smart contract developer can set an amount by assigning an integer to a property _amount of a smart object.","For example, consider the class Payment below.","If a user A wants to send 210000 satoshis to a user B, the user A can setup the payment as follows:","When the payment smart object is created, the wallet inside the computerA object funds the 210000 satoshi that are stored in the payment object.","Generally, constructor and function calls with no parameters work in the same way: The computer object that either created or synced against the smart object has to cover the satoshis in a smart object without parameters.","In the case of a constructor or function call with parameters we first check if the parameters contain enough funds to cover the amount in the parameters after the call and the amount(s) in the return value. If so, no additional fees from the \"current\" wallet is needed. If the amount in the parameters exceeds the amount specified in the smart object the funds are sent back to the \"current\" wallet.","In the next step, A can send send payment._rev to user B. To claim the funds user B can execute:","At the end of the process 210000-10000= 200000 many additional satoshis will be in the wallet with seed B's seed phrase."]}],[{"l":"API Reference","p":["This section outlines the API for the Computer class, which allows for the creation and storage of smart objects on the blockchain. It also enables querying for the location of these objects and calculating their latest values. The Computer class serves as the primary interface for the Bitcoin Computer API."]},{"l":"Basic"},{"l":"Constructor","p":["The \"Computer\" class constructor creates objects capable of creating smart contract transactions as well as standard payments. Each such object is connected to a Bitcoin or Litecoin node and can broadcast transactions and access blockchain information. The constructor parameters are optional and can be used to specify the target blockchain, network, and wallet."]},{"i":"new","l":"new()","p":["This method creates new smart objects. The parameters are a class, a list of arguments for the constructor of the class, and a module specifier. The arguments can be of basic data type or smart objects.","Here a Location is the type"]},{"i":"query","l":"query()","p":["Returns an array of strings, containing the latest revisions of smart objects that satisfy certain conditions. For example, one can obtain all revisions owned by a public key or all revisions of a specific smart contract.","When a key is omitted, the condition is ignored. For example, if only class is set in the contract parameter, the call will return all revisions of that class regardless of the owners."]},{"i":"sync","l":"sync()","p":["This returns the smart object stored at a given revision."]},{"l":"Advanced","p":["Most smart contracts can be implemented using the basic methods. However, the following methods can be used to implement more complex contracts that use for example off-chain signing or server-side funding."]},{"i":"encode","l":"encode()","p":["Encodes an expression, an environment and a module specifier into a Bitcoin transaction of type Transaction as in the Bitcore Library."]},{"i":"decode","l":"decode()","p":["Converts a Bitcore transaction into a transition object. The inverse of encode."]},{"i":"encodenew","l":"encodeNew()","p":["Encodes a smart object creation into a Bitcoin transaction."]},{"i":"encodecall","l":"encodeCall()","p":["Encodes a smart object call into a Bitcoin transaction that can be broadcasted to the Bitcoin mining network."]},{"l":"Modules"},{"l":"export","p":["To optimize blockchain storage and reduce transaction costs, consider exporting your modules. This separates the modules from your smart objects, enabling the code for a class to be stored just once. Later in the text, we'll explain the process of funding, signing, and broadcasting the transaction."]},{"l":"import","p":["Imports a smart contract from a module specifier. Future versions of the library will support importing modules from within an expression. For now, you can import modules from the blockchain using the revision as described in the previous section."]},{"l":"Wallet"},{"l":"fund","p":["Funds a Bitcoin transaction with UTXOs from the wallet."]},{"l":"sign","p":["Signs a Bitcore transaction with the private key of the wallet. The transaction needs to be fully funded before it can be signed. If multiple parties are involved in the transaction, each party needs to sign the transaction before it can be broadcasted."]},{"l":"broadcast","p":["Broadcasts a Bitcoin transaction to the Bitcoin mining network."]},{"l":"send","p":["Sends an amount of satoshis to an address."]},{"l":"rpcCall","p":["Calls a Bitcoin RPC method with the given parameters."]},{"l":"getAddress","p":["Returns a string encoding Bitcoin address."]},{"l":"getBalance","p":["Returns the current balance in satoshi."]},{"l":"getPublicKey","p":["Returns a string encoding a public key."]},{"l":"getChain","p":["Returns the chain of the computer object."]},{"l":"getNetwork","p":["Returns the network of the computer object."]},{"l":"getMenmonic","p":["Returns a string encoding a BIP32 mnemonic sentence of the computer object."]},{"l":"getPassphrase","p":["Returns the passphrase of the computer object."]},{"l":"getPrivateKey","p":["Returns a string encoding a private key."]},{"i":"getpublickey-1","l":"getPublicKey","p":["Returns a string encoding a public key."]},{"l":"getUtxos","p":["Returns an array of UTXOs."]}],[{"l":"Tutorial","p":["A Litecoin node optimized for smart contract applications. The server-side component of the Bitcoin Computer.","Includes a Litecoin node, a PostgreSQL database, and an API","Trustless access to Litecoin transactions created with the Bitcoin Computer Library","Index structures for retrieving UTXOs storing smart contract data","Storage for off-chain data","Docker integration for easy deployment","Exposes an RPC to enable traditional Litecoin development","Synchronizes in parallel for faster and more efficient performance","Support for Bitcoin and Dogecoin coming soon"]},{"l":"Installation","p":["Clone the Bitcoin Computer Monorepo from GitHub. Move to monorepo/packages/node and copy the file .env.example into a file .env in the root folder.","You need to have Docker and yarn installed. You can install them manually or run the script setup.sh in the folder scripts.","Then close and reopen the terminal window to make sure that the Docker daemon is running and run yarn install."]},{"l":"Usage"},{"l":"Start the Node","p":["To start the Bitcoin Computer Node on Litecoin (LTC) regtest run:","You will see the logs of the services that make up the Bitcoin Computer Node: a Litecoin Node called node, a database called db and api server called bcn. Until the database is up and running, messages indicating connection attempts are be logged. The node will be ready when the logs stop running (this can take a few minutes).","Use the -t option to start the node on testnet. Type yarn up -h to get the list of all configuration options. The node will start to download and sync to the Litecoin testnet blockchain."]},{"l":"Fund the Wallet","p":["You need to fund the wallet before you can run the tests. On regtest you can run","On mainnet you need to send Litecoin to the address in question (you can find the address in the error message)."]},{"l":"Run the Tests","p":["To run the tests, execute"]},{"l":"Stop the Node","p":["To stop the Bitcoin Computer Node run","To stop the Bitcoin Computer Node, reset the database, delete all blockchain data, and stop all docker containers, run the following command"]},{"l":"Syncing in parallel","p":["If your machine has more than 4 cores you can run the sync process in parallel to shorten the synchronization time. This is only required on testnet and mainnet.","By default synchronization process is carried out in parallel by using all your available cores. Also, you can use a flag to indicate an specific number of dedicated cores.","The synchronization process can be stopped at any time with the command yarn down -t. When you restart the process, it will continue from the last block processed."]},{"l":"Connect to Bitcoin Computer Lib","p":["Have a look at the documentation for how to connect a Bitcoin Computer Lib instance to your Bitcoin Computer Node."]},{"l":"Server Costs","p":["108.28 USD","10h 30m","16","16GB","2","239.62 USD","28h","32GB","4","440.64 USD","4h 44m","66.82 USD","7h 10m","8","CPUs","Monthly Costs","RAM","Sync Time","The following table shows the estimated times and costs for syncing to a Litecoin node on testnet. The costs are estimated using an AWS EC2 instance prices. All experiments were run using a 50GB SSD storage."]},{"l":"Price","p":["It is free to develop and test a Bitcoin Computer application on testnet and regtest.","On Mainnet the fees for using the Bitcoin Computer are on average the same as the transaction fees charged by miners fees. For example, if the miner transaction fee is one cent, then you pay two cent in total: one cent to the miners, and one cent to support the development of the Bitcoin Computer."]},{"l":"Development Status","p":["We are not aware of security vulnerabilities but there is the possibility of unknown security vulnerabilities. We have performed two internal audits and have fixed all issues that were discovered. Each time the application was refactored heavily. We will will perform one more internal audit before we recommend to use the Bitcoin Computer in production."]},{"l":"Documentation and Help","p":["Have a look at the Bitcoin Computer Docs. If you have any questions, please let us know in our Telegram group, on Twitter, or by email clemens@bitcoincomputer.io."]},{"l":"License","p":["This software is licensed under the Creative Commons Attribution-NoDerivs 3.0 Unported license.","You are free to: share, copy, and redistribute the material in any medium or format for any purpose, even commercially under the following terms:","Attribution — You must give appropriate credit, provide a link to the license, and indicate if changes were made. You may do so in any reasonable manner, but not in any way that suggests the licensor endorses you or your use.","NoDerivatives — If you remix, transform, or build upon the material, you may not distribute the modified material.","This is a human-readable summary of (and not a substitute for) the license."]}]]