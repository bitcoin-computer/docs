[[{"i":"#","p":["This is a custom description for this page"]},{"l":"Bitcoin Computer","p":["Turing Complete smart contracts on Bitcoin"]},{"l":"Simple","p":["Bitcoin Computer makes it possible to run smart contracts on Bitcoin. Smart contracts are Javascript classes and you can store instances of these classes (objects) on the Bitcoin blockchain. Each object has a unique location on the blockchain and if you know the location you can read the state of the object. The state can only be updated by function calls so that constraints on data updates can be enforced.","You can build games, social networks, NFTs, fungible tokens, stable coins, exchanges, auctions, voting, office applications, artificial intelligence, every application you can think of. Building applications couldn't be simpler, just build a client side web application and whenever you want to store something in a database just use our client side lib to store an object on the blockchain. Usually the entire backend can be replaced by a smart contract which can vastly simplify development."]},{"l":"Efficient","p":["On other blockchains fees are charged for every computational step and for every memory allocation. On Bitcoin there is no fee per computational step or memory allocation. This is because smart contracts are evaluated client side as opposed to by miners. Bitcoin Computer smart contracts are lightweight and do not impose any additional effort on nodes and miners. The only fee that needs to be paid is for the block space required to encode the name of the function being called and its parameters. This is mostly less than a few cents. This makes it possible, for the first time, to run compute and memory intense programs as smart contracts."]},{"l":"Trustless","p":["You can run your own node. The node gives you trustless access to the Bitcoin Computer. Nobody can revoke your access if you have a copy of the node and the lib. You can think of a node as a universal backend that can power any application. You can run a node easily through docker.","We are launching on Litecoin. In the future we want to support all currencies in the Bitcoin family."]}],[{"l":"Examples"},{"i":"non-fungible-tokens-nfts","l":"Non-Fungible Tokens (NFTs)","p":["A non-fungible token is an object that stores an image url, the title of an artwork, and the name of a artist.","A keyword property _owners is set to a public key. The holder of that public key is the owner of the object in the sense the corresponding private key is required to update the object. To send the NFT to another user, the current owner can reassign the _owners property to the new owner's public key.","You can find a working implementation for minting, storing, and sending NFTs on Github."]},{"l":"Fungible Tokens","p":["A fungible token is initialized to a fixed supply and an initial owner.","The only function is a send function. This function checks that the supply of the token is above the amount to be sent. If so the amount stored in this instance is decreased by \"amount\". Then a new instance of the token class is created. The owner of the new token is set to the recipient.","See Github."]},{"l":"Chat","p":["A chat is an object that stores a list of messages that is initially empty. It has a function invite that adds another user to the _owners array thereby giving them write access (only the creator of the chat can post and invite users initially). Once invited a user can call post to send a message to the chat and invite other users.","Try it out on Github."]}],[{"l":"Getting Started"},{"l":"Run the Tests","p":["The easiest way to get started is to run the tests. If you get an error have a look here."]},{"i":"run-in-nodejs","l":"Run in Node.js","p":["Create file index.mjs","Then, execute the following in the same directory","If you get an error \"Insufficient balance\" you have to fund the wallet, have a look here. If the wallet is funded you will see:","You can clone the boilerplate or watch the video walkthrough"]},{"l":"Run in the Browser","p":["Create file index.js.","Create file index.html","Run the following in an empty directory and open your browser at http://localhost:1234.","More info in this video"]}],[{"l":"Tutorial","p":["This tutorial explains how smart objects can be created and updated on the Bitcoin blockchain, and how multiple users can synchronize to the same smart object."]},{"l":"The Computer Object","p":["The first step is to create an object computer from the Bitcoin Computer npm package. import from 'bitcoin-computer'","All keys are optional. You can generate a fresh BIP39 seed phrase using a seed phrase generator."]},{"l":"Creating a Smart Object","p":["The new() method of the computer object creates a smart object from a Javascript class and an array of arguments for the constructor. A Bitcoin transaction is broadcast to record the creation of the object.","Every smart object has a property _ id that is set to the output on the Bitcoin blockchain that records the creation of the smart object. This id remains fixed throughout the lifecycle of the object."]},{"l":"Updating a Smart Object","p":["A smart object can be updated by calling one of its functions. When a smart object is updated a transaction is broadcast that records the state change. It is therefore necessary to await on function calls.","When a smart object is updated a transaction is broadcast that records the state change. It is therefore necessary to awaiton function calls.","A new output is created that stores the new revision of the smart object. The property counter._ rev.is set to the output that stores the latest revision."]},{"l":"Reading a Smart Object","p":["The ``computer.sync()` method returns a smart object given a revision. This allows one user to create a smart object, send the revision of the smart object to another user, and the second user can synchronize to the same object. For example a user Alice could run the following code","Next, Alice sends the revision ac445f8aa0e6503cf2e...03cf2e/0 to her friend Bob. Bob can create an instance of the same smart object on his local machine.","At this point, both Alice and Bob both have a local instance of the same smart object. Additionally, there is an instance of the counter object that is stored in the blockchain. The instance on the blockchain is the global source of truth. If either user has permission to updates the object the other user can recompute the state of the object so that both remain in consensus. Consider, for example, that Alice calls the inc function on her local machine:","The object on Alice's computer updates the counter to 1. Next, the update is recorded on the blockchain in a transaction. Finally, Bob can sync to the latest revision of the object to compute its latest state. Bob can obtain the latest revision if he knows the owner of the smart object. This concept is explained in the next section."]},{"l":"Data Ownership","p":["Every smart object has a property _owners that can be set as a list of public key strings. A smart object can only be updated by a user whose public key is in the _owners array. Specifically, a smart object can only be updated if it was created by a computer instance (either by computer.new or computer.sync ) that contains a mnemonic that corresponds to a public key in the current _owners property. The _owners property can be set in a constructor call and updated in a function call. If no _owners property is specified, it defaults to a singleton array containing the public key of the current computer object. The following example shows how the _owners property can be assigned in construction and function calls.","In the following example Alice can call the inc function but Bob cannot:"]},{"l":"Money","p":["A smart object can store an amount of Bitcoin. The amount of Bitcoin, denominated in satoshi, is set through the _ amount property. The Bitcoin is owned by the owners of the object, and each owner can send the Bitcoin to another user (like themselves). As an example consider the class Wallet below.","The following example shows how a wallet storing 30000 satoshi is created. The satoshi are taken out of the wallet of the computer object. If a function call reduces the amount of satoshi in an object the remaining satoshi (minus miner fee) are returned to the wallet in the computer object. The example also shows how the wallet can send Bitcoin."]}],[{"l":"Api","p":["This Api describes the class Computer that can create and synchronize to smart objects, the class DB that can read, write, and update data on the blockchain, and the class Wallet, a Bitcoin wallet."]},{"l":"Computer","p":["The constructor of the Computer class takes one argument as shown below.","The constructor returns an object computer that contains a sub-object computer.db of class Dband a sub-object computer.db.wallet of class Wallet. In this section we explain the functions of the Computer class and we explain the Db and Wallet class in the following sections. computer.new","The new() method creates new smart objects. It has two parameters, a class and a list of arguments. The arguments can be basic data types or smart objects.","We encode an output as a string of the form /. We refer to an output encoded in this form as a location.","The new() method returns a smart object generated from the class and the arguments. It broadcasts a transaction that records the creation of the smart object. The smart object has the methods and properties defined in the class, and four extra properties:","_ id: the location where the object is deployed. The id remains fixed throughout the lifecycle of the object.","_ rev: the location where the object is currently stored. Initially _ id and _ rev are identical. When a method of the smart object is called its new state is stored at a new location, which is stored in the _ rev property.","_ owners: an array containing string encoded public keys. A function can only be called on a smart object if it was created by a computer instance that contains a private key corresponding to a public keys in the list of owners.","_ amount: a number encoding the number of satoshis stored in the smart object.","The properties _ id and _ rev are read-only but the properties _ owners and _ amount can be assigned in constructor and function calls."]},{"i":"computersync","l":"computer.sync","p":["The sync() method returns the smart object stored at a given revision.","After running the code above a1 and a2 will be distinct objects with identical values."]},{"i":"computergetrevs","l":"computer.getRevs","p":["The getRevs() method returns an array containing the latest revisions owned by a given public key. The public keys are string encoded. If no parameter is passed to getRevs() the public key of the computer object is used."]},{"i":"computergetlatestrev","l":"computer.getLatestRev","p":["The getLatestRev() method inputs an id and returns the latest revision of the smart object with that id. If no smart object with that id exists an error is thrown.","After running the above code rev will be equal to a._ rev if a1 is a smart object."]},{"l":"Db","p":["The recommended way to create an instance of the Db class is to create an object of the Computer class and to access its property computer.db."]},{"i":"dbput","l":"db.put","p":["The put() method inputs an array of JSON objects and stores them in a transaction. Each element of the array is stored in a separate output. The method returns the array of locations of the outputs created."]},{"i":"dbget","l":"db.get","p":["The get() method returns the JSON objects stored at a given array of locations."]},{"i":"dbupdate","l":"db.update","p":["The update() method has two parameters: a list of locations and a list of JSON objects. It broadcasts a transaction that spends the locations and that has one output for each JSON object.","You can use db.get() to inspect the smart contract protocol. Try to call db.get()with the ids or rev of a smart object to see the data on the blockchain. Remember to pass the id inside an array likedb.get([a._ id])."]},{"l":"Wallet","p":["We recommend creating a Wallet instance by creating a Computer instance and accessing the nested wallet property.","The wallet built into Bitcoin Computer is compatible with the widely used Bitcore library. This makes it easy to integrate Bitcoin Computer into existing apps."]},{"i":"walletgetmenmonic","l":"wallet.getMenmonic","p":["The getMnemonic() method returns a Bitcore compatible Javascript object encoding a Mnemonic. To return the mnemonic string call the toString() method."]},{"i":"walletgetpublickey","l":"wallet.getPublicKey","p":["The getPublicKey() method returns a Bitcore compatible Javascript object encoding a public key. To return the public key in string encoding call the toString() method."]},{"i":"walletgetaddress","l":"wallet.getAddress","p":["The getAddress() method returns a Bitcore compatible Javascript object encoding a Bitcoin address. To return the address in string encoding call the toString() method."]},{"i":"walletgetbalance","l":"wallet.getBalance","p":["The getBalance() method returns the current balance in satoshi."]},{"i":"walletsend","l":"wallet.send","p":["The send() method sends an amount of satoshi to an address."]}],[{"l":"Troubleshooting"},{"i":"wallet-is-currently-rescanning-abort-existing-rescan-or-wait","l":"Wallet is currently rescanning. Abort existing rescan or wait.","p":["When you use a seed phrase for the first time, the Bitcoin node needs to re-scan the blockchain. This usually takes around 10m but can take up to an hour. Just wait and try again."]},{"l":"Insufficient balance in address","p":["You need to fund the wallet inside the computer object.","The Bitcoin Computer currently supports Litecoin testnet. You can get free testnet coins from a Litecoin Testnet Faucet here, here, here, or here. We recommend generating a new seed phrase through a BIP39 generator."]}],[{"l":"Getting Help","p":["If you have any questions or are having trouble writing a smart contract please get in touch. You can","ask a question in the Telegram Group","create and issue on Github","We can also help you develop a smart contract on the Bitcoin Computer. Email clemens@bitcoincomputer.io for more information."]}]]