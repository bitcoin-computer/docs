[[{"i":"#","p":["This is a custom description for this page"]},{"l":"Bitcoin Computer","p":["A smart contract system for UTXO-based blockchains. Key features include:","Low fees through client-side validation","Cost independent of time and space complexity","Smart contract programming in Javascript and Typescript","Access to all historical states","Built-in privacy through encryption","Efficient block space usage with off-chain storage","ES6 module system","Pure and secure, no need for a side-chain","Support for Litecoin with support for Bitcoin and Dogecoin coming soon.","With these features, you can build a variety of decentralized applications, such as tokens, exchanges, games, social networks, and more."]},{"l":"Get Started","p":["Bitcoin Computer"]},{"l":"Examples","p":["To run an example have a look at the README.md file in the corresponding folder."]},{"l":"Applications","p":["Wallet: A minimal non-custodial wallet","Chat: A p2p chat application where messages are communicated over the blockchain","Fungible Token: An application for minting, sending, and storing fungible tokens","Non Fungible Token: An application for minting, sending, and storing non-fungible tokens (NFTs)"]},{"l":"Standard Smart Contracts","p":["BRC20 contract: A implementation of the ERC20 Fungible Token Standard","BRC721 contract: A implementation of the ERC721 Non-Fungible Token Standard"]},{"l":"Templates","p":["Bitcoin Computer Node.js Template: A template for starting a new Bitcoin Computer application with node.js","Bitcoin Computer React Template: A template for starting a new Bitcoin Computer application with Create React App"]},{"l":"Core Library","p":["The core smart contract library is based on two packages:","Bitcoin Computer Lib A non-custodial web wallet for reading and writing smart contracts","Bitcoin Computer Node Server side infrastructure for providing trustless access to smart contracts"]},{"l":"Price","p":["It is free to develop and test a Bitcoin Computer application on testnet and regtest.","On Mainnet the fees for using the Bitcoin Computer are on average the same as the transaction fees charged by miners fees. For example, if the miner transaction fee is one cent, then you pay two cent in total: one cent to the miners, and one cent to support the development of the Bitcoin Computer."]},{"l":"Development Status","p":["We have completed two internal audits and addressed any discovered issues. Currently, there are no known security vulnerabilities, however, it is possible that unknown vulnerabilities may exist. We plan to conduct one more thorough internal security audit prior to recommending the usage of the Bitcoin Computer in production environments."]},{"l":"Getting Help","p":["If you have any questions, please let us know in our Telegram group, on Twitter, or by email clemens@bitcoincomputer.io."]},{"l":"License","p":["Bitcoin Computer Lib and Bitcoin Computer Node are licensed under the Creative Commons Attribution-NoDerivs 3.0 Unported License. All other packages in this monorepo are licensed under the MIT License. See the individual packages for more information."]}],[{"l":"Start","p":["If you are trying out the Bitcoin Computer for the first time, or you want to integrate it into a new or existing application, we recommend to follow the readme file of the Bitcoin Computer Library.","Bitcoin Computer Library"]},{"l":"Run a Node","p":["You can run a Bitcoin Computer Node through docker. You need to run a node if you want to run an application on mainnet. It also offers a great development experience.","Bitcoin Computer Node"]},{"l":"Host an Application","p":["You can run one of the example applications by cloning the monorepo.","Bitcoin Computer Monorepo"]}],[{"l":"Tutorial"},{"l":"Write a Smart Contract","p":["Every Javascript (ES6) class that extends from Contract is a smart contract. For example, a smart contract for a chat could be:"]},{"l":"Create a Wallet","p":["You can create a smart contract wallet from the Bitcoin Computer library.","You can pass in a BIP39 mnemonic to initialize the wallet. To generate a fresh mnemonic click here. You can find more wallet configuration options here."]},{"l":"Create a Smart Object","p":["The computer.new function can be used to create a smart object from a smart contract. For example","When this call is executed, a transaction containing the expression `${Chat} new Chat('hi')` is broadcast. The object a that is returned has all the properties defined in the class, and five extra properties _id, _rev, _root, _owners and _amount.","The properties _id, _root and _rev are set to the same value: 667c...2357/0. We will explain these properties in detail later, for now it is sufficient to know that 667c...2357 is the transaction id of the transaction that contains the expression `${Chat} new Chat('hi')`. The property _owners is an array of public keys that are allowed to update the object. The property _amount is the amount of satoshis that are stored in the object."]},{"l":"Read a Smart Object","p":["The computer.sync function can be used to parse the expressions on transactions back into Javascript objects. For example, if we call computer.sync with the string 667c...2357/0 it will recover the original object:","Reading and writing can be performed to different users. The blockchain allows them to obtain consensus over the state of smart objects. This makes it possible to build decentralized applications."]},{"l":"Update a Smart Object","p":["A smart object can be updated through function calls. Function calls are also recorded in transactions. Therefore it is necessary to await on function calls:","We can see that the messages array was updated as expected.","Additionally, it can be observed that _rev has been updated, but _id and _root remains unchanged. Every time a smart object is updated a new revision is created and assigned to the _rev property. We will explain the _id and the _root property in detail later, for now we note that they remain fixed throughout the lifecycle of an object.","Revisions allow you to reconstruct each historical state of an object:"]},{"l":"Find Smart Objects","p":["The computer.query function provides a simple way of finding the latest revision of a smart object.","A basic pattern is to identify smart objects by their id, look up their latest revision using computer.query and then to compute their current state using computer.sync. For example, in a chat, we might have the url for the chat containing the id of the chat object. We could then recover the latest state of the chat as follows:"]},{"l":"Data Ownership","p":["Every smart object has up to three owners and only an owner can update the object. The owners can be set by assigning string encoded public keys to the _owners property of a smart object. If the _owners property is not assigned in a smart contract it defaults to the public key of the computer object that created the smart object.","For example, in our chat, the initial owner will be the user that created the chat with computer.new. As a result, only that user will be able to post to the chat, which is a little boring. So we can add a function to update the owners array, to invite more participants to the chat."]},{"l":"Privacy","p":["By default, the state of all smart objects is publicly visible. However, you can restrict read access to the object by setting a property _readers. If _readers is assigned to an array of public keys, the meta-data of the current revision is encrypted in a way that only the specified readers can decrypt it.","For example, if we want to ensure that only people invited to the chat can read the messages, we can update our example code as follows:","A user can (only) read the state of a smart object if they have read access to the current and all previous versions of the object. It is, therefore, not possible to revoke access that has already been granted from smart objects. However, it is possible to remove a user's ability to read the state of a smart object from a point in time forwards.","Both encryption and decryption happen securely in users' browsers. We note that while all smart contract data is encrypted, flows of money are not obfuscated in order not to hinder anti-money laundering efforts."]},{"l":"Saving Block Space","p":["It is sometimes not the best choice to store data on the blockchain. For example, if there's a large amount of data, it might be too expensive. Other data, like personal data, should never be stored on chain, not even encrypted, in order to comply with privacy regulations, such as CCPA and GDPR.","The property _url of each smart object can be used to specify the URL of a Bitcoin Computer Node. When this property is set, the meta data that encodes an update is not recorded on the blockchain, but instead is stored on the specified Bitcoin Computer Node. The blockchain only contains a hash of the meta data and a link to where it can be retrieved.","For example, if we want to allow users to send images that are too large to be stored on chain to the chat, we can make use of the off-chain solution:"]},{"l":"Cryptocurrency","p":["Each smart object can store an amount of cryptocurrency. By default a smart object stores a minimal (non-dust) amount. The smart contract developer can set an amount by assigning an integer to a property _amount of a smart object.","For example, consider the class Payment below.","If a user A wants to send 210000 satoshis to a user B, the user A can setup the payment as follows:","When the payment smart object is created, the wallet inside the computerA object funds the 210000 satoshi that are stored in the payment object.","Generally, constructor and function calls with no parameters work in the same way: the computer object that either created or synced against the smart object has to cover the satoshis in a smart object without parameters.","When a constructor or function is called with parameters, it is first evaluated if they hold sufficient funds to cover the cost of the call and the returned value. If they do, no additional fees are taken from the \"current\" wallet. If the amount in the parameters surpasses the amount specified in the smart object, the excess funds are returned to the \"current\" wallet.","For B to claim the funds, in the next step A can send payment._rev to user B. Then, the user B can execute:","At the end of the process 210000-10000=200000 many additional satoshis will be in the wallet with seed B's seed phrase."]}],[{"l":"Protocol","p":["The Bitcoin Computer protocol enables the recording of Javascript program executions within Bitcoin transactions. This allows the state of Javascript objects, referred to as \"smart objects,\" to be stored on the blockchain. The transactions contain Javascript expressions that encode changes to the smart objects' state, and the outputs correspond to the state of the objects after the update. Spent outputs represent the historical states while unspent outputs represent the current state. By evaluating the Javascript expressions in the transactions, both the past and current state of the smart objects can be determined, resulting in the creation of a global shared memory.","Just as you can use any library function without a deep understanding of how it is evaluated, the vast majority of smart contracts can be built with the Bitcoin Computer using the basic interface. To gain a better understanding of the protocol, this document explains at a high level how the basic interface is implemented using the advanced interface."]},{"l":"The Global Shared Memory","p":["A Bitcoin Computer Transaction is a Bitcoin transaction that contains the following metadata:","A Javascript expression, such as new Counter() or counter.inc(), which may contain free variables like counter.","A blockchain environment object that associates the free variables in the expression to the inputs of the transaction.","An optional module specifier, which points to a transaction output storing a module.","We show corresponding input-output paris vertically aligned.","Assume that some one-to-one mapping between the inputs and outputs called correspondence can be computed from the transaction. Allocation and de-allocation in the global shared memory can be encoded as follows:","An output that does not have a corresponding input is a memory allocation","An an output that has a corresponding input is a memory update","An input that does not have a corresponding input is a de-allocation","A revision is an output that encodes either a memory allocation or update. The computer.sync function computes a Javascript object from each revision. These objects are called smart objects."]},{"l":"Keyword Properties","p":["In addition to the properties defined in the class that a smart object is created from, it has the following properties:","_id: Refers to the transaction output that allocated the memory cell that stores the smart object. This id remains constant, even if the object is updated.","_rev: Refers to the last transaction output that updated the smart object. It is updated every time the object is updated.","_root: For an object created using computer.new, the _ root is equal to its _ id. If an object is created within a function call, the _ root of the new object is the _ root of the object on which the function was called.","_amount: Indicates the amount of cryptocurrency (in satoshi) stored in the smart object.","_owners: An array of string-encoded public keys representing the owners of the object. Only the owners can update a smart object by calling one of its functions."]},{"l":"Calling Constructors","p":["To allocate a memory cell and to store a new smart object in it, a transaction that contains a Javascript expression e 1; e 2... e n where e n is of the form new C(...) must be broadcast. The class C can be defined in the expression or it can be passed in from a module.","The function computer.sync computes Javascript objects from outputs as shown in the figure. Note that _id, _rev, and _root are all set to the same output."]},{"l":"Calling Functions","p":["To update a smart object stored in the shared global memory, a Bitcoin transaction must be broadcast that includes a Javascript expression of the form of x.f(...). To determine which memory cell the free variable x is stored in, the blockchain environment must associate x with an input. In the example this input is shown as nft.","The transaction will create corresponding outputs to these inputs, which represent the updated state of the memory cells. These outputs are called the revisions of a smart object, and the most recent revision is stored in the _rev property of the smart object.","The computer.sync function can be called with each revision of a smart object. This provides access to all historical states of a smart object."]},{"l":"Returning Objects","p":["When a function call on a smart object returns a value of type object, a new memory cell is allocated to store the returned value.","The figure below illustrates the minting and sending of 100 fungible tokens. The blue user, with public key 03a1d..., mints the tokens in the first transaction, producing one output that represents the 100 newly minted tokens. The second transaction represents the distribution of tokens after the blue user sends 3 tokens to the green user, with public key 03f0b....","The blue output of the second transaction represents the 97 tokens that the blue user still holds, while the green output represents the three tokens now owned by the green user. The _ root property of both outputs in the second transaction is linked to the output of the first transaction, as the memory cell for the three tokens was allocated within a function call.","This setup prevents forgery, as any two tokens with the same root can be traced back to the same mint. To mint a second token with the same root, one would have to broadcast a transaction with the transaction id of the first transaction, which is impossible."]}],[{"l":"API","p":["This section outlines the API for the Computer class, which allows for the creation and storage of smart objects on the blockchain. It also enables querying for the location of these objects and calculating their latest values. The Computer class serves as the primary interface for the Bitcoin Computer API."]},{"l":"Basic"},{"l":"Constructor","p":["The \"Computer\" class constructor creates objects capable of creating smart contract transactions as well as standard payments. Each such object is connected to a Bitcoin or Litecoin node and can broadcast transactions and access blockchain information. The constructor parameters are optional and can be used to specify the target blockchain, network, and wallet."]},{"l":"new","p":["This method creates new smart objects. The parameters are a class, a list of arguments for the constructor of the class and a module specifier. The arguments can be of basic data type or smart objects.","Here a Location is the type"]},{"l":"query","p":["Returns an array of strings, containing the latest revisions of smart objects that satisfy certain conditions. For example, one can obtain all revisions owned by a public key or all revisions of a specific smart contract.","When a key is omitted, the condition is ignored. For example, if only class is set in the contract parameter, the call will return all revisions of that class regardless of the owners."]},{"l":"sync","p":["This returns the smart object stored at a given revision."]},{"l":"Advanced","p":["Most smart contracts can be implemented using the basic methods. However, the following methods can be used to implement more complex contracts that use for example off-chain signing or server-side funding."]},{"l":"encode","p":["Encodes an expression, an environment and a module specifier into a Bitcoin transaction of type Transaction as in the Bitcore Library."]},{"l":"decode","p":["Converts a Bitcore transaction into a transition object. The inverse of encode."]},{"l":"encodeNew","p":["Encodes a smart object creation into a Bitcoin transaction."]},{"l":"encodeCall","p":["Encodes a smart object call into a Bitcoin transaction that can be broadcast to the Bitcoin mining network."]},{"l":"Modules"},{"l":"export","p":["To optimize blockchain storage and reduce transaction costs, consider exporting your modules. This separates the modules from your smart objects, enabling the code for a class to be stored just once. The process of funding, signing, and broadcasting a transaction will be explained later in the text."]},{"l":"import","p":["Imports a smart contract from a module specifier. Future versions of the library will support importing modules from within an expression. For now, you can import modules from the blockchain using the revision as described in the previous section."]},{"l":"Wallet"},{"l":"fund","p":["Funds a Bitcoin transaction with UTXOs from the wallet."]},{"l":"sign","p":["Signs a Bitcore transaction with the private key of the wallet. The transaction needs to be fully funded before it can be signed. If multiple parties are involved in the transaction, each party needs to sign the transaction before it can be broadcasted."]},{"l":"broadcast","p":["Broadcasts a Bitcoin transaction to the Bitcoin mining network."]},{"l":"send","p":["Sends an amount of satoshis to an address."]},{"l":"rpcCall","p":["Calls a Bitcoin RPC method with the given parameters."]},{"l":"getAddress","p":["Returns a string encoding Bitcoin address."]},{"l":"getBalance","p":["Returns the current balance in satoshi."]},{"l":"getPublicKey","p":["Returns a string encoding a public key."]},{"l":"getChain","p":["Returns the chain of the computer object."]},{"l":"getNetwork","p":["Returns the network of the computer object."]},{"l":"getMenmonic","p":["Returns a string encoding a BIP32 mnemonic sentence of the computer object."]},{"l":"getPassphrase","p":["Returns the passphrase of the computer object."]},{"l":"getPrivateKey","p":["Returns a string encoding a private key."]},{"i":"getpublickey-1","l":"getPublicKey","p":["Returns a string encoding a public key."]},{"l":"getUtxos","p":["Returns an array of UTXOs."]}],[{"l":"Wallet","p":["A wallet allows a user to check their balance and make a transaction to send cryptocurrency to another user.","In order to build the transaction, we can use a Bitcore-style library. Bitcoin Computer Lib can provide data to the wallet and broadcast the transaction. A BIP39 mnemonic sentence can be employed to generate a Bitcoin Computer wallet.","You can use the computer object to calculate the balance of a given address.","The easy way to send money to a friend is to use the send function:","Check out a working version on Github"]}],[{"l":"Chat","p":["The Bitcoin Chat presented here is a hackable chat that runs on the blockchain. The chat does not need a database backend because all data is stored on the blockchain (currently runs on LTC testnet). The interface between the chat and the blockchain is provided by Bitcoin Computer.","The Chat class has a constructor and two functions, post and invite.","The constructor initializes a owner of the chat and an empty messages array. The post function stores the new messages, and the invite function records the users who join the chat.","Check out a working version on Github."]}],[{"l":"Non-Fungible Token","p":["Let's explore how ERC721 style non-fungible token (NFT) contracts can be implemented on Bitcoin.","In the NFT class, we have a constructor and a send function. The constructor initializes a new token with a url and an initial owner. The send function adds the new owner to the list of owners of this token."]},{"l":"BRC721","p":["BRC721 is the ERC721 standard built on Bitcoin. It currently implements the IBRC721 interface.","The BRC721 class has the following functions: mint, balanceOf, ownerOf, and transfer. The mint function mints a new non-fungible token. It first checks whether or not there is a masterNFT. If not, and a name and a symbol are inputted, the computer generates a new NFT, which includes the name and symbol and a new owner's information, and sets it as this BRC721's masterNFT. If there's already a masterNFT, but its name does not match the name inputted, or the symbol does not match, throw an error. Otherwise, the masterNFT will mint a new token with the new owner's information.","The balanceOf function returns the number of NFTs the user owns. The ownerOf function returns the owner of a given token ID. The transfer function allows you to send the token to another user.","Check out a working version of the BRC721 contract and a NFT application."]}],[{"l":"Fungible Token","p":["We explore how ERC20 style fungible token contracts can be built on Bitcoin. The BRC20 class implements the interface described in EIP20.","We use two classes: a TokenBag encapsulates the minimal amount of data that needs to be stored on the blockchain. A token bag can be thought of as the equivalent to unspent transaction output (utxo) in the token world: while a utxo stores a number of satoshi, a token bag stores a number of tokens. The ERC20 class helps manage multiple token bags, in the same way that a wallet deals with multiple unspent outputs."]},{"l":"Token Bag","p":["The constructor of the TokenBag class initializes a new token bag with a number of tokens and an initial owner. It also sets a name and a symbol for the token bag.","The transfer function checks if there are sufficiently many tokens to send the amount. It throws an error if insufficient funds are detected. Otherwise, it decrements the number of tokens in the current bag by amount and creates a new smart object of type TokenBag that is owned by the recipient and stores the amount many tokens.","We note that calls to the transfer function do not change the overall number of tokens: when a new token bag with a number of tokens is created, that same number of tokens is removed from another object (the object on which the transfer function is called).","This is because all function calls on the Bitcoin Computer are atomic in the sense that either all instructions in a function are evaluated or none of them."]},{"l":"Adding Approval","p":["Approval is a mechanism in of the ERC20 contract where a user called spender is granted the right to spend certain number of tokens of the original owner.","We add two properties approvals and originalOwner to the TokenBag class and two methods approve and disapprove to grant and revoke approval. For now, these methods work on an all or nothing bases for all tokens in the bag."]},{"l":"BRC20","p":["In general, each user will own several token bags, in the same way that users generally own multiple unspent outputs. The BRC20 class adds functionality for sending tokens from multiple bags and for computing their balance across multiple bags. This is similar to the functionality of a traditional Bitcoin wallet.","There is plenty of room for improvement with this class: one issue is that when a payment is made from multiple bags, all payments are sent in separate transactions. In addition, the running time can be vastly improved through the use of caching. Both issues can be solved at the smart contract level and do not require any changes to the Bitcoin Computer.","Check out a working version of the BRC721 contract and a NFT application."]}]]