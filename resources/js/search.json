[[{"i":"#","p":["This is a custom description for this page"]},{"l":"Bitcoin Computer","p":["Turing Complete smart contracts on Bitcoin"]},{"l":"Simple","p":["Bitcoin Computer makes it possible to run smart contracts on Bitcoin. Smart contracts are Javascript classes and you can store instances of these classes (smart objects) on the Bitcoin blockchain. Each smart object has a unique location on the blockchain and if you know the location you can read the state of the object. The state can only be updated by function calls so that constraints on data updates can be enforced.","You can build games, social networks, NFTs, fungible tokens, stable coins, exchanges, auctions, voting, office applications, artificial intelligence, every application you can think of. Building applications is simple: build a client side web application and store data on the blockchain instead of in a database using our client side lib. Often the entire backend can be replaced by a smart contract which can vastly simplify development."]},{"l":"Efficient","p":["On other blockchains fees are charged for every computational step and for every memory allocation. On Bitcoin there is no fee per computational step or memory allocation. This is because smart contracts are evaluated by users client side instead of by miners. This makes Bitcoin Computer smart contracts lightweight as they do not impose any additional effort on miners, node operators, and other users.","The only fee that needs to be paid is the mining fee plus a Bitcoin Computer fee that is equal to the mining fee. This is mostly just a few cents. This makes it possible, for the first time, to run compute and memory intense programs as smart contracts."]},{"l":"Trustless","p":["You can run your own node. The node gives you trustless access to the Bitcoin Computer. Nobody can revoke your access if you have a copy of the node and the lib. You can think of a node as a universal backend that can power any application. You can run a node easily through docker.","We are launching on Litecoin. In the future we want to support all currencies in the Bitcoin family."]}],[{"l":"Fungible Token","p":["We explore how an ERC20 style contracts (as defined in EIP20) can be built on Bitcoin. We use two classes, a TokenBag can stores tokens and has a send function. The ERC20 class makes it possible to deal with multiple token bags in the same way that a wallet deals with multiple unspent outputs."]},{"l":"Token Bag","p":["The constructor of the TokenBag class stores the number of tokens an the initial owner. The send function first checks if there are sufficient funds. If so it creates a new smart object that sends the required number of tokens to the recipient."]},{"l":"Adding Approval","p":["Approval is a mechanism in of the ERC20 contract where a user called spender is granted the right to spend certain number of tokens of the original owner.","We add two properties approvals and originalOwner to the TokenBag class and two methods approve and disapprove to grant and revoke approval. For now these methods work on an all or nothing bases for all tokens in the bag. We also add two propertied name and symbol according to the ERC20 standard."]},{"l":"BRC20","p":["In general each user will own several token bags, in the same way that users generally own multiple unspent outputs. The BRC20 class adds functionality for sending tokens from multiple bags and for computing their balance across multiple bags. This is similar to the functionality of a traditional Bitcoin wallet.","We note that it is not necessary to check a message sender","This is a work in progress and some functions are missing. There is also a partial implementation on Github."]}],[{"l":"Examples"},{"i":"non-fungible-tokens-nfts","l":"Non-Fungible Tokens (NFTs)","p":["A non-fungible token is an object that stores an image url, the title of an artwork, and the name of a artist.","A keyword property _owners is set to a public key. The holder of that public key is the owner of the object in the sense the corresponding private key is required to update the object. To send the NFT to another user, the current owner can reassign the _owners property to the new owner's public key.","You can find a working implementation for minting, storing, and sending NFTs on Github."]},{"l":"Fungible Tokens","p":["A fungible token is initialized to a fixed supply and an initial owner.","The only function is a send function. This function checks that the supply of the token is above the amount to be sent. If so the amount stored in this instance is decreased by \"amount\". Then a new instance of the token class is created. The owner of the new token is set to the recipient.","See Github."]},{"l":"Chat","p":["A chat is an object that stores a list of messages that is initially empty. It has a function invite that adds another user to the _owners array thereby giving them write access (only the creator of the chat can post and invite users initially). Once invited a user can call post to send a message to the chat and invite other users.","Try it out on Github."]}],[{"l":"Getting Started"},{"l":"Run the Tests","p":["The easiest way to get started is to run the tests. If you get an error have a look here."]},{"i":"run-in-nodejs","l":"Run in Node.js","p":["Create file index.mjs","Then, execute the following in the same directory","If you get an error \"Insufficient balance\" you have to fund the wallet, have a look here. If the wallet is funded you will see:","You can clone the boilerplate or watch the video walkthrough"]},{"l":"Run in the Browser","p":["Create file index.js.","Create file index.html","Run the following in an empty directory and open your browser at http://localhost:1234.","More info in this video"]}],[{"l":"Troubleshooting"},{"i":"wallet-is-currently-rescanning-abort-existing-rescan-or-wait","l":"Wallet is currently rescanning. Abort existing rescan or wait.","p":["When you use a seed phrase for the first time, the Bitcoin node needs to re-scan the blockchain. This usually takes around 10m but can take up to an hour. Just wait and try again."]},{"l":"Insufficient balance in address","p":["You need to fund the wallet inside the computer object.","The Bitcoin Computer currently supports Litecoin testnet. You can get free testnet coins from a Litecoin Testnet Faucet here, here, here, or here. We recommend generating a new seed phrase through a BIP39 generator."]}],[{"l":"Getting Help","p":["If you have any questions or are having trouble writing a smart contract please get in touch. You can","ask a question in the Telegram Group","create and issue on Github","We can also help you develop a smart contract on the Bitcoin Computer. Email clemens@bitcoincomputer.io for more information."]}],[{"l":"Tutorial","p":["This tutorial explains how to build an encrypted blockchain-based chat."]},{"l":"The Computer Object","p":["The first step is to create an object computer from bitcoin-computer-lib. The computer object is a wallet that can build and broadcast Bitcoin transactions that encode smart object creations and updates. You can pass in a BIP39 seed phrase to initialize the wallet (you can generate a seed phrase here).","By default a computer object is configured to connect to Litecoin testnet through a publicly available Bitcoin Computer Node. See Section Api for details on the configuration options."]},{"l":"Smart Contracts","p":["Every Javascript (ES6) class is a smart contract. For example, a smart contract for a chat could be:"]},{"l":"Smart Objects","p":["A smart object is a Javascript object that is stored on the Bitcoin blockchain. The computer.new() method inputs a class and an array of arguments for the constructor of the class and returns a smart object from the class.","When a smart object a is created a Bitcoin transaction is broadcast that records the creation of a. One of the outputs of the transaction is the immutable representation of the smart object on the blockchain. This output is called the location of a."]},{"l":"Object Identity","p":["Each smart object a has a unique identity a._id that remains fixed throughout the lifecycle of the object. This identity is the transaction id and the output number of the location of a."]},{"l":"Object Revision","p":["Each smart object a has a revision a._rev that is changed every time the object is updated. Each version of a smart object has a unique identifier that can be used to recover every previous version of a."]},{"l":"Object Root","p":["Each smart object a has a root a._root. For a smart object a created with computer.new the root a._root of a is equal to a._id. However smart objects can also be created inside a constructor or function call on another smart object b. In this case the root of a is the root of b."]},{"l":"Updating a Smart Object","p":["Smart objects can be updated through function calls (it is not possible to assign to a property of a smart object directly). When a function is called, a transaction is broadcast that spends the output representing the smart object before the function call and creates a new unspent output (utxo) representing the object after the function call. Note that is necessary to await on function calls as broadcasting a transaction is an asynchronous operation.","It is important to note that a user can only call a function of a smart object a if that user can spend the output that stores the current state of a. This is the basis of the security model of the Bitcoin Computer."]},{"l":"Data Ownership","p":["Every smart object a contains an array a._owners of public key strings. This array can be used to restrict write access to the smart object: in order to call a function on a a user needs a private key matching one of the public keys in the a._owners array.","It is possible to reassign the a._owners property to change the ownership of a. If the property is not assigned in function calls it is unchanged and in constructor calls it defaults to the public key of the computer object that created a.","For example, in our chat, only the user that created the chat can post initially. However, we can add an invite function to the chat to allow other users to post."]},{"l":"Encryption","p":["By default the state of all smart objects is publicly visible. However, every smart object a has a property a._readers that can be used to restrict read access to a. If a._readers is set, the meta data of the current revision is encrypted so that only the specified readers can decrypt it. If the a._readers is not assigned, it remains unchanged in function calls and defaults to the public key of the computer object that created a.","For example, if we want to ensure that only people invited to the chat can read the messages, we can update our example code as follows:","A user can (only) read the state of a smart object if they have read access to the current and all previous versions of the object. It is therefore not possible to revoke access from smart objects that has already been granted. It is however possible to remove a user's ability to read the state of a smart object from a point in time forwards.","Both encryption and decryption happens securely in user's browsers. We note that while all smart contract data is encrypted flows of money are not obfuscated in order to not hinder anti money laundering efforts."]},{"l":"Finding Smart Objects","p":["The process of reading the current stat of a smart objects a consists of two steps: finding the latest revision of a and synchronizing to the revision (synchronizing will be described in the next Section)."]},{"l":"Querying by Ownership","p":["The computer.queryRevs() method returns an array of all revisions that satisfy certain conditions as specified in the parameter. For example, one can obtain all revisions owned by a public key or all revisions of a specific smart contract."]},{"l":"Querying by Identity","p":["It is often convenient to refer a smart object by its identity. In order to synchronize to the latest version of the object its latest revision is needed. The computer.idToRev() function returns the latest revision of a given id.","Multiple ids can be passed in and their revisions will be returned in order."]},{"l":"Synchronizing to a Smart Object","p":["The computer.sync() method returns a smart object given a revision.","In the example of our decentralized chat, a user could first synchronize to the chat to read the messages. If the user is an owner the user can post a message."]},{"l":"Off-Chain Storage","p":["It is sometimes not the best choice to store data on chain. For example if the data is big it might be too expensive. Other data, like personal data, should never be stored on chain, not even encrypted, in order to comply with end user privacy regulation such as CCPA and GDPR.","Each smart object a has a property a._url that can be set to the url of a Bitcoin Computer Node. When this property is set the meta data that encodes an update is not stored on the blockchain but on the Bitcoin Computer Node at the given url. The blockchain contains only the hash of the meta data and a link to where the data can be obtained from.","For example, if we want to allow users to send images to the chat that are too large to be stored on chain, we can make use of the off-chain solution:","The meta data for that specific call will be stored on the Bitcoin Computer Node at https://my.node.example.com. The only data that is stored on the blockchain is the url and the hash of the data. The cost of calling postPic is therefore independent of the size of picBuf."]},{"l":"Sending and Storing Cryptocurrency","p":["Each smart object a can store an amount of cryptocurrency a._amount. The cryptocurrency is owned by the owners of the object, and each owner can send the Bitcoin to another user by reassigning the a._owners property."]}],[{"l":"API","p":["We describe th Api of the class Computer. Objects of the class can create and synchronize to smart objects. It also provides the usual methods of a wallet."]},{"l":"Constructor","p":["Creates a new Bitcoin Computer wallet."]},{"l":"Smart Contract Interface"},{"i":"new","l":"new()","p":["Creates new smart objects. The arguments are a class and a list of arguments for the constructor of the class. The arguments can be of basic data type or smart objects."]},{"i":"sync","l":"sync()","p":["Returns the smart object stored at a given revision."]},{"i":"queryrevs","l":"queryRevs()","p":["Returns an array containing the latest revisions that satisfy certain conditions.","When a key is omitted the condition is ignored. For example, if only className is set the call will return all revision of that class regardless of the owners."]},{"i":"idtorev","l":"idToRev()","p":["Inputs an id and returns the latest revision of the smart object with that id. If no smart object with that id exists an error is thrown."]},{"l":"Wallet Interface"},{"i":"getmenmonic","l":"getMenmonic()","p":["Returns a string encoding a BIP93 mnemonic sentence of the computer object."]},{"i":"getpublickey","l":"getPublicKey()","p":["Returns a string encoded a public key."]},{"i":"getaddress","l":"getAddress()","p":["Returns a string encoded Bitcoin address."]},{"i":"getbalance","l":"getBalance()","p":["Returns the current balance in satoshi."]},{"i":"send","l":"send()","p":["Sends an amount of satoshi to an address."]},{"i":"broadcast","l":"broadcast()","p":["Support will be added in 0.9.0-beta","Broadcasts a hex encoded Bitcoin transaction to the Bitcoin mining network."]}],[{"l":"Api","p":["Docs coming soon."]}],[{"l":"Tutorial","p":["Docs coming soon.","For now have a look at the readme of the npm package."]}],[{"l":"Wallet","p":["A wallet allows a user to check their balance and to build a transaction to send cryptocurrency to another user.","A Bitcore-style library can be used to build the transaction. Bitcoin Computer Lib can be used to provide data to the wallet and to broadcast the transaction. A BIP39 mnemonic sentence can be used to generate a bitcoin computer wallet.","Computing the balance is a two step process. The first step is to find all the unspent transaction outputs (utxos) of the address. The utxos store the cryptocurrency. The second step is to sum up the satoshis in the utxos.","The easy way to implement the send function is to use the Bitcoin Computer wallet."]},{"l":"The Hard Way","p":["It is also possible to use the Bitcoin Computer and a Bitcore style library to build a transaction directly. This is interesting because the smart contract for a fungible token is conceptually similar to the code used to build a wallet.","The first step is to query for all utxos. We add inputs to the transactions that spend the utxos until we have enough to cover the amount. We then add the output to create a new utxo that the receiver can spend. The last thing left to do it to sign and braodcast the transaction.","The \"Advanced Examples\" Section is are a work in progress. We are using the examples in this section to determine the final syntax and semantics for the Bitcoin Computer."]}],[{"l":"Fungible Token","p":["We explore how ERC20 style contracts can be built on Bitcoin. The code is implemented and tested here.","We use two classes: a TokenBag encapsulates the minimal amount of data that needs to be stored on the blockchain. A token bag can be thought of as the equivalent to unspent transaction output (utxo) in the token world: while a utxo stores a number of satoshi a token bag stores a number of tokens. The ERC20 class helps manage multiple token bags, in the same way that a wallet deals with multiple unspent outputs."]},{"l":"Token Bag","p":["The constructor of the TokenBag class initializes a new token bag with a number of tokens and an initial owner. It also sets a name and a symbol for the token bag.","The send function checks if there are sufficiently many tokens to send the amount. It throws an error if insufficient funds are detected. Otherwise it decrements the number of tokens in the current bag by amount and creates a new smart object of type TokenBag that is owned by the recipient and stores the amount many tokens.","We note that calls to the send function do not change the overall number of tokens: when a new token bag with a number of tokens is created that same number of tokens is removed from another object (the object on which the send function is called).","This is because all function calls on the Bitcoin Computer are atomic in the sense that either all instructions in a function are evaluated or none of them."]},{"l":"Adding Approval","p":["Approval is a mechanism in of the ERC20 contract where a user called spender is granted the right to spend certain number of tokens of the original owner.","We add two properties approvals and originalOwner to the TokenBag class and two methods approve and disapprove to grant and revoke approval. For now these methods work on an all or nothing bases for all tokens in the bag.","You can find the MIT licensed source code on Github."]},{"l":"BRC20","p":["In general each user will own several token bags, in the same way that users generally own multiple unspent outputs. The BRC20 class adds functionality for sending tokens from multiple bags and for computing their balance across multiple bags. This is similar to the functionality of a traditional Bitcoin wallet.","There is plenty of rooms for improvement with this class: one issue is that when a payment is made from multiple bags, all payments are sent in separate transaction. In addition the running time can be vastly improved through the use of caching. Both issues can be solved at the smart contract level and do not require any changes to the Bitcoin Computer.","The BRC20 class implements the interface described in EIP20. Have a look at the implementation on Github.","The \"Advanced Examples\" Section is are a work in progress. We are using the examples in this section to determine the final syntax and semantics for the Bitcoin Computer."]}]]