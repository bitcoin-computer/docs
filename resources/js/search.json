[[{"i":"#","p":["This is a custom description for this page"]},{"l":"Bitcoin Computer","p":["A smart contract system for UTXO-based blockchains. Key features include:","Clients validate instead of trusting the operator","Transaction fee are low and independent of time and space complexity","Smart contract are written in Javascript or Typescript","Access to all historical states","Built-in privacy through encryption","Efficient block space usage with off-chain storage","ES6 module system based on inscriptions","No side-chain","No extra token","Support for Litecoin with support for Bitcoin and Dogecoin coming soon.","You can build decentralized applications, such as tokens, exchanges, games, social networks, and more."]},{"l":"Get Started","p":["Bitcoin Computer"]},{"l":"Examples","p":["To run an example have a look at the README.md file in the corresponding folder."]},{"l":"Applications","p":["Wallet: A minimal non-custodial wallet","Chat: A p2p chat application where messages are communicated over the blockchain","Fungible Token: An application for minting, sending, and storing fungible tokens","Non Fungible Token: An application for minting, sending, and storing non-fungible tokens (NFTs)"]},{"l":"Standard Smart Contracts","p":["BRC20 contract: A implementation of the ERC20 Fungible Token Standard","BRC721 contract: A implementation of the ERC721 Non-Fungible Token Standard"]},{"l":"Templates","p":["Bitcoin Computer Node.js Template: A template for starting a new Bitcoin Computer application with node.js","Bitcoin Computer React Template: A template for starting a new Bitcoin Computer application with Create React App"]},{"l":"Core Library","p":["The core smart contract library is based on two packages:","Bitcoin Computer Lib A non-custodial web wallet for reading and writing smart contracts","Bitcoin Computer Node Server side infrastructure for providing trustless access to smart contracts"]},{"l":"Price","p":["It is free to develop and test a Bitcoin Computer application on testnet and regtest.","On Mainnet the fees for using the Bitcoin Computer are on average the same as the transaction fees charged by miners fees. For example, if the miner transaction fee is one cent, then you pay two cent in total: one cent to the miners, and one cent to support the development of the Bitcoin Computer."]},{"l":"Development Status","p":["We have completed two internal audits and addressed any discovered issues. Currently, there are no known security vulnerabilities, however, it is possible that unknown vulnerabilities may exist. We plan to conduct one more thorough internal security audit prior to recommending the usage of the Bitcoin Computer in production environments."]},{"l":"Getting Help","p":["If you have any questions, please let us know in our Telegram group, on Twitter, or by email clemens@bitcoincomputer.io."]},{"l":"License","p":["Bitcoin Computer Lib and Bitcoin Computer Node are licensed under the Creative Commons Attribution-NoDerivs 3.0 Unported License. All other packages in this monorepo are licensed under the MIT License. See the individual packages for more information."]}],[{"l":"Start","p":["If you are trying out the Bitcoin Computer for the first time, or you want to integrate it into a new or existing application, we recommend to follow the readme file of the Bitcoin Computer Library.","Bitcoin Computer Library"]},{"l":"Run a Node","p":["You can run a Bitcoin Computer Node through docker. You need to run a node if you want to run an application on mainnet. It also offers a great development experience.","Bitcoin Computer Node"]},{"l":"Host an Application","p":["You can run one of the example applications by cloning the monorepo.","Bitcoin Computer Monorepo"]}],[{"l":"Tutorial"},{"l":"Write a Smart Contract","p":["Smart contracts are Javascript classes that extend from Contract. For example, a smart contract for a simple chat is","Our goal is that every Javascript class that extends from Contract can be used, but we are not there yet. For example, it is currently not possible to assign to this in constructors. Instead you can initialize a smart object by passing an argument into super as shown above."]},{"l":"Create a Wallet","p":["To create a wallet call the constructor of the Computer class.","You can pass in a BIP39 mnemonic to initialize the wallet. To generate a fresh mnemonic click here. You can find more wallet configuration options here."]},{"l":"Create a Smart Object","p":["The computer.new function can be used to create a smart object from a smart contract. For example","When this call is executed, a transaction is broadcast that contains both the source code of Chat as well as the expression new Chat('hello'). The object a that is returned has all the properties defined in the class, and five extra properties _id, _rev, _root, _owners and _amount.","The additional properties are explained in detail in the Protocol. For now it is sufficient to know that 667c...2357 is the transaction id of the transaction that contains the expression `${Chat} new Chat('hello')`. The property _owners is an array of public keys that are allowed to update the object. The property _amount is the amount of satoshis that is stored in the object."]},{"l":"Read a Smart Object","p":["The computer.sync function computes the state of smart object from the transactions on the blockchain. For example, synchronizing to 667c...2357:0 will return an object with the same value as a.","Smart objects are readable by any user by default, but they can be encrypted for privacy. The computer.sync function is deterministic, therefore multiple users can get consensus over the state of a smart object."]},{"l":"Update a Smart Object","p":["Smart objects can only be updated through function calls. Whenever a function of a smart object is called a transaction is broadcast to record the function call. Therefore it is necessary to await on all function calls.","Note that _rev has been update but that _id and _root stayed the same. Every time a smart object is updated a new revision is created and assigned to the _rev property. Revisions allow you to reconstruct each historical state of an object."]},{"l":"Find a Smart Object","p":["The computer.query function can find the latest revision of smart objects from different parameters like their ids.","A basic pattern for many applications is to identify smart objects by their id, look up their latest revision using computer.query and then to compute their current state using computer.sync. For example, in a chat, we might have the url for the chat containing the id of the chat object. We could then recover the latest state of the chat as follows:"]},{"l":"Data Ownership","p":["Every smart object can have up to three owners. Only an owner can update the object. The owners can be set by assigning string encoded public keys to the _owners property of a smart object. If the _owners property is not assigned in a smart contract it defaults to the public key of the computer object that created the smart object.","In the chat example the initial owner is the user that created the chat with computer.new. Thus only this user will be able to post to the chat. We can add a function to update the owners array to invite more guests to chat."]},{"l":"Privacy","p":["By default, the state of all smart objects is public. However, you can restrict read access to an object by setting a property _readers. If _readers is assigned to an array of public keys in a constructor of function call, the meta-data of that call is encrypted using a combination of AES and ECIES. Only the specified readers can decrypt an encrypted object using the computer.sync function.","For example, if we want to ensure that only people invited to the chat can read the messages, we can update our example code as follows:","A user can (only) read the state of a smart object if they have read access to the current and all previous versions of the object. It is, therefore, not possible to revoke access to a revision. However, it is possible to remove a user's ability to read the state of a smart object from a point in time forwards.","When the _readers property is set the data is end-to-end encrypted users' browsers. Even when smart objects are encrypted the flow of cryptocurrency is not obfuscated so that anti-money laundering efforts are not hindered."]},{"l":"Off-Chain Storage","p":["Not all data needs to be stored on the blockchain. For example, personal data should never be stored on chain, not even encrypted.","When the property _url of a smart object is set to the URL of a Bitcoin Computer Node, the metadata of the current function call is stored on the specified Bitcoin Computer Node. The blockchain contains a hash of the meta data and a link to where it can be retrieved.","For example, if we want to allow users to send images that are too large to be stored on chain to the chat, we can make use of the off-chain solution:"]},{"l":"Cryptocurrency","p":["Each smart object can store an amount of satoshi. By default a smart object stores a minimal (non-dust) amount. If the _amount property of a smart object is set to a number, the output storing that smart object will contain that number of satoshis. For example, consider the class Payment below.","If a user A wants to send 210.000 satoshis to a user B, the user A can setup the payment as follows:","When the payment smart object is created, the wallet inside the computerA object funds the 210.000 satoshi that are stored in the payment object. Once user B becomes aware of the payment, he can withdraw by syncing against the object and calling the cashOut function.","One more transaction is broadcast for which user B pays the fees. This transaction has two outputs: one that records that the cashOut function was called with 546 satoshi and another that spends the remaining satoshi to computerB.getAddress()."]}],[{"l":"API","p":["The Computer class can create and update smart objects and query for the location and latest revision of these."]},{"l":"Overview"},{"l":"Basic"},{"l":"Constructor","p":["An instance of the Computer class is a smart contract enabled wallet. It has the usual features of a wallet like sending payments or checking the balance of an address. In addition it can create smart objects by encoding these in Bitcoin transactions and broadcasting them to the blockchain."]},{"l":"new","p":["Creates a new smart object. The parameters are a smart contract (a Javascript class inheriting from Contract), a list of arguments for the constructor of the class and an optional module specifier. The arguments of the constructor can be of basic data type or smart objects.","Here a Location is the type","The new function builds a transaction that records the creation of a new smart object, signs it and broadcasts it. Smart objects can be updated by calling their functions, see here."]},{"l":"sync","p":["Returns the smart object stored at a given revision."]},{"l":"query","p":["Returns the latest revisions of smart objects. Conditions can be passed in to determine the smart objects. When multiple conditions are passed in, the latest revisions of the smart objects that satisfy all conditions are returned."]},{"l":"Advanced","p":["The functions encode and decode provide the core functionality of the Bitcoin Computer: recording Javascript expressions on the blockchain and computing their values. The basic interface is syntactic sugar on top of the basic interface. The advanced interface is a more efficient than the basic interface and it provides access to advanced features."]},{"l":"encode","p":["The encode function evaluates a Javascript expression on a blockchain. It returns a Bitcoin transaction and an object of type Effect.","The object of type Effect captures the changes induced by evaluating the expression: It contains the result of the evaluation (property res) and the side effects of the evaluation (property env). The object of type Effect can be used to determine if the evaluation had the desired effect. If it did, the transaction can be broadcast to commit the update to the blockchain. If the transaction is not broadcast, the state on the blockchain does not change. The transaction can be broadcast at an arbitrarily long delay after calling encode. If during the time between calling encode and broadcasting the transaction the blockchain undergoes any updates that could affect the evaluation, the miners will reject the transaction. However, if the transaction is accepted by the miners, it is guaranteed to have the effect indicated by object of type Effect.","If the expression contains free variables (for example the variable x in the expression x.f()) an environment must be passed in to define where the free variables are defined. Specifically, an environment is a JSON object that maps variables to their respective revisions.","If a module specifier is provided, the exports of that module are imported when the expression is evaluated. The module specifier can also be used to query for all objects that were created in expressions that imported that module specifier.","Other options can customize the funding and signing process."]},{"l":"decode","p":["Converts a Bitcoin transaction into a transition object. The inverse of encode if only exp, env, and mod are provided."]},{"l":"encodeNew","p":["Encodes a smart object creation."]},{"l":"encodeCall","p":["Encodes a function call on a smart object."]},{"l":"Modules"},{"l":"deploy","p":["The deploy function broadcasts a transaction containing an ES6 module. The return value is a string encoding the location where the object is stored. Modules can also import other modules that have been deployed to the blockchain previously (see example below).","Deploying your code has the advantage that many objects can import the same module. This saves transaction fees, as large pieces of code can be deployed once and then used to create or update many smart objects.","Please note that modules are currently not encrypted, even if objects that use them have the _readers property set.","Previously this function was called export but this name is deprecated since version 0.16.0."]},{"l":"load","p":["Imports a ES6 module from a module specifier.","Previously this function was called import but this name is deprecated since version 0.16.0."]},{"l":"Wallet"},{"l":"fund","p":["Funds a Bitcoin transaction."]},{"l":"sign","p":["Signs a Bitcoin transaction. Options can be passed in that determine which inputs to sign, the sigHash type to use, and which script to use."]},{"l":"broadcast","p":["Broadcasts a Bitcoin transaction to the Bitcoin mining network."]},{"l":"send","p":["Sends a payment."]},{"l":"rpcCall","p":["Calls a Bitcoin RPC method with the given parameters."]},{"l":"getAddress","p":["Returns a string encoding Bitcoin address."]},{"l":"getBalance","p":["Returns the current balance in satoshi."]},{"l":"getPublicKey","p":["Returns a string encoding a public key."]},{"l":"getChain","p":["Returns the chain."]},{"l":"getNetwork","p":["Returns the network."]},{"l":"getMnemonic","p":["Returns a string encoding a BIP39 mnemonic sentence."]},{"l":"getPassphrase","p":["Returns the BIP39 passphrase."]},{"l":"getPrivateKey","p":["Returns a string encoded private key."]},{"i":"getpublickey-1","l":"getPublicKey","p":["Returns a string encoded public key."]},{"l":"getUtxos","p":["Returns an array of unspent transaction outputs (UTXOs)."]}],[{"l":"Protocol","p":["The Bitcoin Computer protocol records the execution of Javascript programs in Bitcoin transactions that contain meta data. The objects created by these programs can be associated with the outputs of Bitcoin transactions. Spent outputs represent historical states and unspent outputs (UTXOs) represent the current state. Both the current and all historical states of a smart object can be computed from the metadata on the blockchain.","Just like you can use a programming language without knowing in detail how it is evaluated, you can use the Bitcoin Computer without understanding it's protocol. However if you are interested in how smart contracts work on Bitcoin, you can find more information below."]},{"l":"The Global Shared Memory","p":["The Global Shared Memory is a low level abstraction that makes smart contracts possible on Bitcoin. It is comparable to the ordinals protocol in that is assigns names to outputs, thereby connecting outputs with the same name.","Allocation and de-allocation in the global shared memory can be encoded as follows:","The n-th output of a transaction with m inputs is called","a memory update if n <= m","a memory allocation if m < n","A memory de-allocation is an input at index n in a transaction with m < n outputs","We can assign two names, \"revisions\" and \"ids\", to all outputs: The revision of an output is the concatenation of its transaction id and output number. The id of an output is it's revision if the output is a memory allocation. If an output o is a memory update then the transaction contains an input i with the same index of o. In this case o's revision is the revision of the output being spent by i."]},{"l":"Smart Contracts","p":["Smart contracts can be build on top of the shared global memory using the Bitcoin Computer protocol. A Bitcoin Computer Transaction is a Bitcoin transaction that contains the following metadata:","A Javascript expression, such as new Counter() or counter.inc(), which may contain free variables like counter.","A blockchain environment object that associates the free variables in the expression with the inputs of the transaction.","An optional module specifier, which identifies a transaction output storing a module.","The computer.sync function computes an Javascript object for each output of a Bitcoin Computer transaction. The object is annotated with the id and revision of the cell in global memory that stores the object. Such an object is called a smart object."]},{"l":"Keyword Properties","p":["In addition to the properties defined in the class that a smart object is created from, it has the following properties:","_id: Refers to the transaction output that allocated the memory cell that stores the smart object. This id remains constant, even if the object is updated.","_rev: Refers to the last transaction output that updated the smart object. It is updated every time the object is updated.","_root: For an object created using computer.new, the _ root is equal to its _ id. If an object is created within a function call, the _ root of the new object is the _ root of the object on which the function was called.","_amount: Indicates the amount of cryptocurrency (in satoshi) stored in the smart object.","_owners: An array of string-encoded public keys representing the owners of the object. Only the owners can update a smart object by calling one of its functions."]},{"l":"Calling Constructors","p":["To allocate a memory cell and to store a new smart object in it, a transaction that contains a Javascript expression e 1; e 2... e n where e n is of the form new C(...) must be broadcast. The class C can be defined in the expression or it can be passed in from a module.","The function computer.sync computes Javascript objects from outputs as shown in the figure. Note that _id, _rev, and _root are all set to the same output."]},{"l":"Calling Functions","p":["To update a smart object stored in the shared global memory, a Bitcoin transaction must be broadcast that includes a Javascript expression of the form of x.f(...). To determine which memory cell the free variable x is stored in, the blockchain environment must associate x with an input. In the example this input is shown as nft.","The transaction will create corresponding outputs to these inputs, which represent the updated state of the memory cells. These outputs are called the revisions of a smart object, and the most recent revision is stored in the _rev property of the smart object.","The computer.sync function can be called with each revision of a smart object. This provides access to all historical states of a smart object."]},{"l":"Returning Objects","p":["When a function call on a smart object returns a value of type object, a new memory cell is allocated to store the returned value.","The figure below illustrates the minting and sending of 100 fungible tokens. The blue user, with public key 03a1d..., mints the tokens in the first transaction, producing one output that represents the 100 newly minted tokens. The second transaction represents the distribution of tokens after the blue user sends 3 tokens to the green user, with public key 03f0b....","The blue output of the second transaction represents the 97 tokens that the blue user still holds, while the green output represents the three tokens now owned by the green user. The _ root property of both outputs in the second transaction is linked to the output of the first transaction, as the memory cell for the three tokens was allocated within a function call.","This setup prevents forgery, as any two tokens with the same root can be traced back to the same mint. To mint a second token with the same root, one would have to broadcast a transaction with the transaction id of the first transaction, which is impossible."]}]]